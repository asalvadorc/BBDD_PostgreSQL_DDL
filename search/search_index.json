{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Dades","title":"Bases de Dades"},{"location":"#bases-de-dades","text":"","title":"Bases de Dades"},{"location":"1_introducci/","text":"1. Introducci\u00f3 Fins ara hem treballat amb un servidor PostgreSQL al n\u00favol que tenia dues bases de dades: geo i factura . En aquestes bases de dades \u00fanicament f\u00e8iem consultes (SELECT) i ning\u00fa modificava l\u2019estructura ni les dades, per aix\u00f2 no hi havia conflictes. A partir d\u2019ara, amb les sent\u00e8ncies de DDL i DML, farem el seg\u00fcent: DDL \u2192 crear i eliminar taules, columnes, esquemes\u2026 DML \u2192 inserir, modificar i eliminar dades Per tant, no ens conv\u00e9 en absolut treballar sobre la Base de Dades geo ni sobre factura , ja que el que far\u00edem seria \"boicotejar-nos\" entre nosaltres. Aix\u00ed, a partir d\u2019ara, en lloc de fer \u00fas d\u2019un servidor allotjat al n\u00favol, treballareu amb un servidor PostgreSQL de manera local, utilitzant contenidors Docker . En tot cas, seguirem utilitzant el client DBeaver per connectar-nos i gestionar la base de dades. Treballarem amb dues Bases de Dades noves en local utilizant contenidors: proves : servir\u00e0 per a fer proves, com el seu propi nom indica. Tots els exemples del tema els farem en aquesta BD. factura_local : tindreu una Base de Dades per a cadasc\u00fa en local. \u00c9s on haureu de treballar els exercicis. Anem a fer la instal\u00b7laci\u00f3: 1.1 Instal\u00b7laci\u00f3 de Docker \ud83d\udd39Windows 1) Verifica els requisits i activa la virtualitzaci\u00f3/WSL2: Activa WSL 2 i comprova la versi\u00f3 amb: wsl --version (Si no apareix, instal\u00b7la-ho/actualitza-ho amb: wsl --install / wsl --update ). 2) Instal\u00b7la Docker Desktop: https://www.docker.com/products/docker-desktop 3) Assegura\u2019t que Docker Compose est\u00e0 disponible (normalment ve incl\u00f2s amb Docker Desktop): Executa: docker compose version i, si respon amb una versi\u00f3 (per exemple, \u00abDocker Compose version vX.Y.Z\u00bb), est\u00e0 instal\u00b7lat i accessible en el teu PATH. \ud83d\udd39Ubuntu (en les aules del centre educatiu no fa falta fer la instal\u00b7laci\u00f3) 1) Instal\u00b7la Docker: sudo apt update sudo apt install docker.io 2) Instal\u00b7la Docker Compose: sudo apt install docker-compose 1.2 PostgreSQL amb Docker Compose 1) En una carpeta, per exemple, docker/postgres_local , crea l\u2019arxiu buit docker-compose.yml . El fitxer docker-compose.yml defineix el contenidor de PostgreSQL, la seva configuraci\u00f3 i els ports per a connectar-se des de DBeaver. Copia el contingut seg\u00fcent dins del fitxer docker-compose.yml services: postgres: image: postgres:16.4 container_name: postgres_local environment: POSTGRES_USER: admin POSTGRES_PASSWORD: admin POSTGRES_DB: postgres ports: - \"5432:5432\" volumes: - postgres_data:/var/lib/postgresql/data volumes: postgres_data: 2) Al\u00e7a el servei : En la carpeta on est\u00e0 el docker-compose.yml , executa en la terminal: docker compose up -d Explicaci\u00f3 dels camps principals: image : indica quina imatge de PostgreSQL utilitzar (en aquest exemple, la versi\u00f3 16.4). container_name : nom que tindr\u00e0 el contenidor. environment : defineix l\u2019usuari, la contrasenya i la base de dades que es crearan inicialment. ports : mapeja el port local 5432 al port 5432 del contenidor, permetent connectar-se des de DBeaver. volumes : mant\u00e9 les dades persistents encara que el contenidor s\u2019aturi o es torni a crear. Consell Pots personalitzar POSTGRES_USER, POSTGRES_PASSWORD i POSTGRES_DB segons les necessitats del teu projecte. 1.3 Crear una connexi\u00f3 des de DBeaver al servidor PostgreSQL creat amb Docker Una vegada el contenidor PostgreSQL est\u00e0 en funcionament, pots connectar-te des de DBeaver seguint aquests passos: 1) Obre DBeaver i connecta\u2019t al servidor PostgreSQL utilitzant les credencials definides en el docker-compose.yml . 2) Fes clic a Database \u2192 New Database Connection . 3) Selecciona PostgreSQL i fes clic a Next. 4) Introdueix les dades de connexi\u00f3 definides en el fitxer docker-compose.yml: Host : localhost Port : 5432 Database : Postgres Username : admin Password : admin 5) Fes clic a Test Connection/Probar Conexi\u00f3n per comprovar que la connexi\u00f3 funciona correctament. 6) Si tot \u00e9s correcte, fes clic a Aceptar . Ara podr\u00e0s veure i gestionar la base de dades PostgreSQL des de DBeaver. Nota Si tens problemes de connexi\u00f3, comprova que el contenidor est\u00e0 en funcionament amb docker ps i que el port 5432 no est\u00e0 ocupat per un altre servei. 1.4 Crear bases de dades dins de la connexi\u00f3 postgres_local Creem les bases de dades proves i factura_local dins de la connexi\u00f3 postgres_local perqu\u00e8 aquesta connexi\u00f3 correspon al servidor PostgreSQL que tenim instal\u00b7lat en local amb Docker . 1) Fes clic dret sobre la connexi\u00f3: postgres_local . 2) Selecciona: Create \u2192 Database 3) En la finestra escriu el nom de la base de dades: proves 4) Fes clic dret sobre la connexi\u00f3 postgres_local . 5) Prem Refresh / Actualitzar . 6) Comprova que apareix la base de dades proves en la llista. 7) Fes els mateixos passos per a la base de dades: factura_local IMPORTANT Us recomane que us creeu una altra connexi\u00f3 per a cadascuna de les Bases de Dades anteriors. D'aquesta manera, segurament, en tindreu tres connexions: la de postgres_local , la de factura_local i la de proves , a m\u00e9s de les connexions al servidor al n\u00favol, geo i factura . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. Introducci\u00f3"},{"location":"1_introducci/#1-introduccio","text":"Fins ara hem treballat amb un servidor PostgreSQL al n\u00favol que tenia dues bases de dades: geo i factura . En aquestes bases de dades \u00fanicament f\u00e8iem consultes (SELECT) i ning\u00fa modificava l\u2019estructura ni les dades, per aix\u00f2 no hi havia conflictes. A partir d\u2019ara, amb les sent\u00e8ncies de DDL i DML, farem el seg\u00fcent: DDL \u2192 crear i eliminar taules, columnes, esquemes\u2026 DML \u2192 inserir, modificar i eliminar dades Per tant, no ens conv\u00e9 en absolut treballar sobre la Base de Dades geo ni sobre factura , ja que el que far\u00edem seria \"boicotejar-nos\" entre nosaltres. Aix\u00ed, a partir d\u2019ara, en lloc de fer \u00fas d\u2019un servidor allotjat al n\u00favol, treballareu amb un servidor PostgreSQL de manera local, utilitzant contenidors Docker . En tot cas, seguirem utilitzant el client DBeaver per connectar-nos i gestionar la base de dades. Treballarem amb dues Bases de Dades noves en local utilizant contenidors: proves : servir\u00e0 per a fer proves, com el seu propi nom indica. Tots els exemples del tema els farem en aquesta BD. factura_local : tindreu una Base de Dades per a cadasc\u00fa en local. \u00c9s on haureu de treballar els exercicis. Anem a fer la instal\u00b7laci\u00f3:","title":"1. Introducci\u00f3"},{"location":"1_introducci/#11-installacio-de-docker","text":"\ud83d\udd39Windows 1) Verifica els requisits i activa la virtualitzaci\u00f3/WSL2: Activa WSL 2 i comprova la versi\u00f3 amb: wsl --version (Si no apareix, instal\u00b7la-ho/actualitza-ho amb: wsl --install / wsl --update ). 2) Instal\u00b7la Docker Desktop: https://www.docker.com/products/docker-desktop 3) Assegura\u2019t que Docker Compose est\u00e0 disponible (normalment ve incl\u00f2s amb Docker Desktop): Executa: docker compose version i, si respon amb una versi\u00f3 (per exemple, \u00abDocker Compose version vX.Y.Z\u00bb), est\u00e0 instal\u00b7lat i accessible en el teu PATH. \ud83d\udd39Ubuntu (en les aules del centre educatiu no fa falta fer la instal\u00b7laci\u00f3) 1) Instal\u00b7la Docker: sudo apt update sudo apt install docker.io 2) Instal\u00b7la Docker Compose: sudo apt install docker-compose","title":"1.1 Instal\u00b7laci\u00f3 de Docker"},{"location":"1_introducci/#12-postgresql-amb-docker-compose","text":"1) En una carpeta, per exemple, docker/postgres_local , crea l\u2019arxiu buit docker-compose.yml . El fitxer docker-compose.yml defineix el contenidor de PostgreSQL, la seva configuraci\u00f3 i els ports per a connectar-se des de DBeaver. Copia el contingut seg\u00fcent dins del fitxer docker-compose.yml services: postgres: image: postgres:16.4 container_name: postgres_local environment: POSTGRES_USER: admin POSTGRES_PASSWORD: admin POSTGRES_DB: postgres ports: - \"5432:5432\" volumes: - postgres_data:/var/lib/postgresql/data volumes: postgres_data: 2) Al\u00e7a el servei : En la carpeta on est\u00e0 el docker-compose.yml , executa en la terminal: docker compose up -d Explicaci\u00f3 dels camps principals: image : indica quina imatge de PostgreSQL utilitzar (en aquest exemple, la versi\u00f3 16.4). container_name : nom que tindr\u00e0 el contenidor. environment : defineix l\u2019usuari, la contrasenya i la base de dades que es crearan inicialment. ports : mapeja el port local 5432 al port 5432 del contenidor, permetent connectar-se des de DBeaver. volumes : mant\u00e9 les dades persistents encara que el contenidor s\u2019aturi o es torni a crear. Consell Pots personalitzar POSTGRES_USER, POSTGRES_PASSWORD i POSTGRES_DB segons les necessitats del teu projecte.","title":"1.2 PostgreSQL amb Docker Compose"},{"location":"1_introducci/#13-crear-una-connexio-des-de-dbeaver-al-servidor-postgresql-creat-amb-docker","text":"Una vegada el contenidor PostgreSQL est\u00e0 en funcionament, pots connectar-te des de DBeaver seguint aquests passos: 1) Obre DBeaver i connecta\u2019t al servidor PostgreSQL utilitzant les credencials definides en el docker-compose.yml . 2) Fes clic a Database \u2192 New Database Connection . 3) Selecciona PostgreSQL i fes clic a Next. 4) Introdueix les dades de connexi\u00f3 definides en el fitxer docker-compose.yml: Host : localhost Port : 5432 Database : Postgres Username : admin Password : admin 5) Fes clic a Test Connection/Probar Conexi\u00f3n per comprovar que la connexi\u00f3 funciona correctament. 6) Si tot \u00e9s correcte, fes clic a Aceptar . Ara podr\u00e0s veure i gestionar la base de dades PostgreSQL des de DBeaver. Nota Si tens problemes de connexi\u00f3, comprova que el contenidor est\u00e0 en funcionament amb docker ps i que el port 5432 no est\u00e0 ocupat per un altre servei.","title":"1.3 Crear una connexi\u00f3 des de DBeaver al servidor PostgreSQL creat amb Docker"},{"location":"1_introducci/#14-crear-bases-de-dades-dins-de-la-connexio-postgres_local","text":"Creem les bases de dades proves i factura_local dins de la connexi\u00f3 postgres_local perqu\u00e8 aquesta connexi\u00f3 correspon al servidor PostgreSQL que tenim instal\u00b7lat en local amb Docker . 1) Fes clic dret sobre la connexi\u00f3: postgres_local . 2) Selecciona: Create \u2192 Database 3) En la finestra escriu el nom de la base de dades: proves 4) Fes clic dret sobre la connexi\u00f3 postgres_local . 5) Prem Refresh / Actualitzar . 6) Comprova que apareix la base de dades proves en la llista. 7) Fes els mateixos passos per a la base de dades: factura_local IMPORTANT Us recomane que us creeu una altra connexi\u00f3 per a cadascuna de les Bases de Dades anteriors. D'aquesta manera, segurament, en tindreu tres connexions: la de postgres_local , la de factura_local i la de proves , a m\u00e9s de les connexions al servidor al n\u00favol, geo i factura . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1.4 Crear bases de dades dins de la connexi\u00f3 postgres_local"},{"location":"2_ddl/","text":"2. DDL DDL ( Data Definition Language ) o Llenguatge de Definici\u00f3 de Dades \u00e9s el conjunt de sent\u00e8ncies que ens permeten definir, retocar o esborrar l'estructura de la Base de Dades. I com que l'estructura b\u00e0sica d'una Base de Dades Relacional \u00e9s la taula, ens dedicarem b\u00e0sicament a estudiar les sent\u00e8ncies que ens permeten definir les taules (o modificar-les o esborrar- les), amb totes les restriccions que hem vist en el Model Relacional: clau principal, claus externes, camps no nuls, ... Tamb\u00e9 veurem altres objectes que podrem definir, sobretot vistes , que es corresponen a l'esquema extern que vam veure en el Tema 1, \u00e9s a dir, la visi\u00f3 particular que pot tenir un usuari. Seran 3 sent\u00e8ncies les que veurem: CREATE , que permet crear un objecte nou. DROP , que permet esborrar un objecte ja existent. ALTER , que permet modificar un objecte ja existent. En el moment de crear una taula definirem tots els seus camps, amb les restriccions pertinents a cadascun d'ells. Cada camp haur\u00e0 de ser d'un tipus de dades. En cada SGBD hi ha uns tipus de dades particulars, encara que els m\u00e9s b\u00e0sics s\u00f3n similars, i en ells ser\u00e0 on incidirem m\u00e9s. 2.1 Tipus de dades En el moment de definir un camp haurem d'especificar obligat\u00f2riament de quin tipus ser\u00e0. Ja es van veure els tipus b\u00e0sics d'Access en el tutorial del tema 5. Ara els veurem els tipus b\u00e0sics de PostgreSQL , i veurem que hi haur\u00e0 molts tipus similars (com en tots els SGBD). En el seg\u00fcent quadre es resumeixen els tipus de dades m\u00e9s importants de PostgreSQL. \u00c9s un conjunt molt extens, que fins i tot pot ampliar l'usuari amb la instrucci\u00f3 CREATE TYPE , com veurem al final del tema. S\u00f3n especialment interessants els tipus geom\u00e8trics (amb POINT , BOX ,...) i el INET (adre\u00e7a IP). Tamb\u00e9 disposarem d'un tipus enumerat. El veurem en l'\u00faltima pregunta del tema. En la documentaci\u00f3 de PostgreSQL trobarem tots els tipus possibles: http://www.postgresql.org/docs/9.5/static/datatype.html 2.2 CREATE TABLE Permet crear una nova taula. Obligat\u00f2riament s'hauran d'especificar els camps i els tipus de dades de cada camp. \u00d2bviament, una vegada creada la taula estar\u00e0 buida, sense cap fila. Sintaxi CREATE TABLE taula ( camp1 tipus [(grand\u00e0ria)] [DEFAULT valor] [restricci\u00f311] [restricci\u00f312] [...] [, camp2 tipus [(grand\u00e0ria)] [DEFAULT valor] [restricci\u00f321] [restricci\u00f322][...] [, ...]] [, restricci\u00f3multiple1 [, ...]] ) Podem observar que la definici\u00f3 de l'estructura de la taula va entre par\u00e8ntesis, separant per comes la definici\u00f3 de cada camp. El nom de la taula no ha de ser el de cap altre objecte anterior (taula o vista). Si volem posar un nom amb m\u00e9s d'una paraula o amb una paraula reservada, l'haurem de posar entre cometes dobles; per\u00f2 no us ho aconselle, \u00e9s preferible la utilitzaci\u00f3 del gui\u00f3 baix, i aix\u00ed nom\u00e9s \u00e9s una paraula. En cada camp posarem el seu nom i el tipus. Si el tipus de dades \u00e9s VARCHAR, podrem posar opcionalment la grand\u00e0ria m\u00e0xima (si no la posem ser\u00e0 de 255 en el cas de text). Si el tipus de dades \u00e9s NUMERIC, podrem posar opcionalment la grand\u00e0ria (n\u00famero de xifres significatives) i n\u00famero de xifres de la part fraccion\u00e0ria. Podem posar ocionalment un valor per defecte amb la cl\u00e0usula DEFAULT . D'aquesta manera, en introduir una nova fila en la taula, si no li posem valor a aquest camp, agafar\u00e0 el valor per defecte. En el valor es pot posar una constant del tipus del camp, o una expressi\u00f3 amb funcions, sempre que torne una dada dels tipus del camp. Podem posar opcionalment restriccions a cada camp. Hauran d'anar abans de la coma que separa del seg\u00fcent camp. Tamb\u00e9 poden haver restriccions que afecten a m\u00e9s d'un camp, que preferiblement posarem al final de la definici\u00f3 de la taula. Veurem les restriccions en el seg\u00fcent punt. Exemples Si voleu practicar aquestos exemples, feu-lo sobre la Base de Dades proves (usuari proves , contrasenya proves ). Si us d\u00f3na error perqu\u00e8 la taula que aneu a crear ja est\u00e0 creada la taula, esborreu-la primer, i torneu a executar la sent\u00e8ncia. 1) Crear una nova taula anomenada EMPLEAT1 amb dos camps, un anomenat dni de tipus text i llarg\u00e0ria 10 i un altre anomenat nom * * amb llarg\u00e0ria 50. CREATE TABLE EMPLEAT1 (dni VARCHAR (10) , nom VARCHAR (50)); 2) Crear una taula anomenada EMPLEAT2 amb un camp text de 10 car\u00e0cters anomenat dni ; un altre camp de tipus text de llarg\u00e0ria predeterminada (255) anomenat nom; un altre camp anomenat data_naixement de tipus data; un altre anomenat sou de tipus num\u00e8ric, amb 6 xifres significatives, de les quals 2 ha de ser de la part fraccion\u00e0ria i un \u00faltim anomenat departament de tipus num\u00e8ric menudet (INT2 o SMALLINT). CREATE TABLE EMPLEAT2 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 ) 3) Crear una taula anomenada EMPLEAT3 com el de l'exemple anterior, per\u00f2 amb dos camps m\u00e9s al final: un camp anomenat poblacio de tipus text de 50 car\u00e0cters, i amb el valor per defecte Castell\u00f3 i un \u00faltim anomenat data_incorporacio de tipus data i valor per defecte la data d'avui CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Exercicis Al llarg d'aquesta tercera part, en el conjunt d'exercicis de DDL, crearem tota l'estructura de la Base de Dades FACTURA , per\u00f2 per a no interferir cadasc\u00fa amb els altres companys, cadasc\u00fa es connectar\u00e0 a la seua Base de Dades factura_local . L'esquema Entitat-Relaci\u00f3 i l'esquema relacional que implementarem ser\u00e0 el seg\u00fcent: En la Base de Dades anomenada factura_local : Ex_1 - Creeu la taula CATEGORIA , amb els mateixos camps i del mateix tipus que en la taula CATEGORIA de FACTURA , per\u00f2 de moment sense clau principal ni cap altra restricci\u00f3. Ex_2 - Creeu la taula ARTICLE , tamb\u00e9 sense restriccions. Nota Durant tots aquestos exercicis de DDL pot ser molt convenient tenir obertes les dues connexions: la de FACTURA (per anar consultant) i la de factura_local (per anar creant i modificant). 2.2.1 Restriccions (Constraint) Per mig de les restriccions podrem definir dins d'una taula restriccions d'usuari com s\u00f3n la definici\u00f3 de la clau principal, claus externes, camps no nuls i camps \u00fanics. Hi ha dues maneres de definir restriccions: les que afecten a un \u00fanic camp (i que es posen en la mateixa definici\u00f3 del camp) i les que afecten o poden afectar a m\u00e9s d'un camp, que s'han de definir separadament de la definici\u00f3 dels camps. Comencem per les primeres, per ser m\u00e9s senzilles d'entendre: 2.2.1.1 Restriccions de camp \u00fanic S\u00f3n restriccions que es posen en la mateixa definici\u00f3 del camp i nom\u00e9s afectaran a aquest camp: van per tant despr\u00e9s del tipus de dades del camp i abans de la coma de separaci\u00f3 dels camps. Sintaxi [ CONSTRAINT nom ] {PRIMARY KEY | UNIQUE | NOT NULL | REFERENCES taula2 [(camp1)] | CHECK (_condici\u00f3_)} Si no posem nom a la restricci\u00f3 (CONSTRAINT nom) PostgreSQL li assignar\u00e0 autom\u00e0ticament un nom. A\u00e7\u00f2 pot resultar c\u00f2mode en ocasions, per a no haver d'inventar-nos noms per a les restriccions, per\u00f2 despr\u00e9s ens limitaria a que no podr\u00edem retocar aquestes restriccions. Els tipus de restriccions que podem definir s\u00f3n: Restricci\u00f3 de clau principal PRIMARY KEY : el camp ser\u00e0 clau principal. Per exemple, d'aquesta manera definirem la taula EMPLEAT3 (com la de l'apartat anterior) amb el camp dni com a clau principal. Recordeu que l'heu d'esborrar primer (potser no l'estigueu visualitzant, per\u00f2 s\u00ed que est\u00e0 creada; refresqueu constantment les taules per saber la situaci\u00f3 actual) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY, nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Nota Podeu comprovar que, si no poseu nom a la restrici\u00f3, \u00e9s a dir, si poseu directament dni TEXT(10) PRIMARY KEY , i aneu al disseny de la taula, PostgreSQL posa autom\u00e0ticament un nom a la restricci\u00f3 format pel nom de la taula seguit de _pkey . Tingueu en compte tamb\u00e9 que si la taula ja existia donar\u00e0 un error. Nom\u00e9s heu d'esborrar-la primer. Restricci\u00f3 d'unicitat UNIQUE : el camp ser\u00e0 \u00fanic, \u00e9s a dir, no es podr\u00e0 agafar dues vegades el mateix valor en aquest camp ( Indexat sense duplicats en Access). PostgreSQL generar\u00e0 autom\u00e0ticament un \u00edndex per a aquest camp. Veurem qu\u00e8 \u00e9s un \u00edndex en la pregunta 6. Per exemple, d'aquesta manera definir\u00edem la taula EMPLEAT3 amb la restricci\u00f3 que el camp nom no es pot repetir (si voleu provar la sent\u00e8ncia feu-lo en la BD proves , i si ja existeix l'esborreu primer): CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR CONSTRAINT u_nom UNIQUE, data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Restricci\u00f3 de valor no nul NOT NULL : el camp no podr\u00e0 agafar un valor nul ( Requerido en Access). Hem de ser conscients que no val la pena definir com a no nula la clau principal, ja que per definici\u00f3 ja ho \u00e9s. Per exemple, d'aquesta manera definirem que el camp nom ha de ser no nul. CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Restricci\u00f3 d'integritat referencial REFERENCES : servir\u00e0 per a definir que aquest camp \u00e9s una clau externa. Haurem d'especificar obligat\u00f2riament la taula a la qual apunta, i opcionalment podem posar entre par\u00e8ntesis el camp de la taula al qual apunta, encara que si no ho posem, per defecte apuntar\u00e0 a la clau principal (i nosaltres sempre voldrem apuntar a la clau principal). Per exemple, d'aquesta manera podem definir la clau externa que apunta a la taula DEPARTAMENT (i que indica que l'empleat pertany al departament). Abans de crear aquesta versi\u00f3 de EMPLEAT3, hem de tenir creada la taula DEPARTAMENT, sin\u00f3 donar\u00e0 error: CREATE TABLE DEPARTAMENT ( num_d INT2 CONSTRAINT cp_dep PRIMARY KEY , nom_d VARCHAR(50) , director VARCHAR(10) , data DATE ); CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ); Com ja es va veure en el tema del Model Relacional (restriccions d'integritat referencial), hi ha 3 maneres d'actuar quan s'esborra o es modifica una fila de la taula principal que t\u00e9 associades files en la taula relacionada per mig de la clau externa. Per exemple, qu\u00e8 fem amb els familiars d'un empleat si esborrem l'empleat? Aquestes maneres d'actuar s'han d'especificar en el moment de definir la clau externa. La manera de posar-les en SQL i el significat s\u00f3n les seg\u00fcents: NO ACTION : no es deixar\u00e0 esborrar o modificar de la taula principal si en t\u00e9 alguna fila relacionada. \u00c9s l'opci\u00f3 per defecte. Aix\u00ed en l'exemple d'EMPLEAT3, amb una clau externa que apunta a DEPARTAMENT, si intentem esborrar o modificar el numero d'un departament que t\u00e9 empleats, ens donar\u00e0 un missatge d'error, avisant que com t\u00e9 registres relacionats en una altra taula no es pot esborrar o modificar. CASCADE : s'esborraran (o modificaran) en cascada els registres relacionats de la taula on est\u00e0 la clau externa. S'especificar\u00e0 amb ON DELETE CASCADE o ON UPDATE CASCADE . CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT ON DELETE CASCADE ON UPDATE CASCADE , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) D'aquesta manera si esborrem un departament de la taula DEPARTAMENT, s'esborraran tamb\u00e9 els empleats de la taula EMPLEATS3 d'aquest departament. I si en la taula DEPARTAMENT modifiquem un n\u00famero de departament, per exemple de 5 a 50, aquest valor ser\u00e0 el nou valor en el camp departament de la taula EMPLEAT3 per a aquells que abans ten\u00eden un 5. SET NULL : posar\u00e0 a nul el camp que \u00e9s clau externa dels registres que estiguen relacionats amb l'esborrat o modificat de la taula principal. Aix\u00ed, si f\u00e9rem la seg\u00fcent definici\u00f3 de la taula EMPLEAT3 CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT ON DELETE SET NULL , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) en el cas que esborrem el departament 5, no donaria cap error per aquesta restricci\u00f3 d'integritat, i posaria a nul el departament d'aquells empleats que abans eren del departament 5. SET DEFAULT : Estableix les columnes que referencien als seus valors per defecte. Ha d'existir una fila en la taula referenicada que coincidixca amb els valors per defecte, si no s\u00f3n NULL, o l'opraci\u00f3 fallar\u00e0. Restricci\u00f3 externa CHECK : far\u00e0 una comprovaci\u00f3 per a validar els valors introdu\u00efts per a aquest camp. La condici\u00f3 de validaci\u00f3 ha d'anar entre par\u00e8ntesis, i ha de ser una expressi\u00f3, normalment de comparaci\u00f3 del camp en q\u00fcesti\u00f3 amb algun valor. Per exemple, anem a exigir que el sou siga estrictament positiu (per tipus de dades num\u00e8ric, podria agafar el valor 0 o valors negatius) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0), departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Evidentment es pot posar m\u00e9s d'una restricci\u00f3 en la definici\u00f3 d'una taula. En aquest exemple arrepleguem totes les anteriors, \u00e9s a dir, definim la taula EMPLEAT3 amb tots els seus camps, i definint la clau principal ( dni ), amb el camp nom \u00fanic , amb el sou estrictament positiu , i amb el camp departament que ser\u00e0 clau externa que apunta a la taula DEPARTAMENT. Per complicar-lo un poc m\u00e9s tamb\u00e9 exigirem que el camp nom siga no nul , i aix\u00ed veure que es pot posar m\u00e9s d'una restricci\u00f3 en un camp. CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY , nom VARCHAR CONSTRAINT u_nom UNIQUE CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Observeu que com a q\u00fcesti\u00f3 d'estil s'han posat noms a les restriccions que d'alguna manera suggereixen el motiu de la restricci\u00f3. Aix\u00ed, cp_emp3 vol dir clau princpal de EMPLEAT3 , u_nom vol dir que el camp nom \u00e9s \u00fanic , nn_nom vol dir que nom \u00e9s no nul , nn_sou vol dir que sou \u00e9s no nul , i ce_emp3_dep vol dir clau externa de la taula EMPLEAT3 a la taula DEPARTAMENT . Si tenim un criteri clar per als noms de les restriccions, si despr\u00e9s les volem desactivar temporalment o senzillament esborrar-les, ho podrem fer des de SQL. 2.2.1.2 Restriccions de camp m\u00faltiple Tamb\u00e9 s'anomenen restriccions de taula, en contraposici\u00f3 a les anteriors, que s\u00f3n restriccions de camp. S\u00f3n restriccions que van dins de la definici\u00f3 d'una taula per\u00f2 fora de la definici\u00f3 d'un camp, i que poden afectar a un o m\u00e9s d'un camp. S'haur\u00e0 de definir expressament a quin o quins camps afecten. Sintaxi [ CONSTRAINT nom ] {PRIMARY KEY | UNIQUE | FOREIGN KEY | CHECK (_condicio_)} (c11 [,c12][,...]) [ REFERENCES taula2 [ (c21 [,c22][,...]) ] ] [ ON DELETE {CASCADE | SET NULL}] [ON UPDATE {CASCADE | SET NULL}] ] Igual que abans, si no posem nom a la restricci\u00f3 (CONSTRAINT nom) PostgreSQL li n'assignar\u00e0 un autom\u00e0ticament, que ser\u00e0 constru\u00eft de manera molt l\u00f2gica. Observeu que ara sempre especifiquem el o els camps afectats. Els tipus de restriccions s\u00f3n els mateixos que en el cas anterior, per\u00f2 la sintaxi variar\u00e0 lleugerament: Restricci\u00f3 de clau principal PRIMARY KEY : posarem entre par\u00e8ntesis el camp o camps (en aquest cas separats per comes) que seran clau principal. Per exemple, definim una altra vegada el camp dni com a clau principal de la taula EMPLEAT3 CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT cp_emp3 PRIMARY KEY (dni) ) I ara un altre per a definir la clau principal de FAMILIAR. Com la clau est\u00e0 formada per 2 camps, estem obligats a utilitzar una restricci\u00f3 de camp m\u00faltiple. CREATE TABLE FAMILIAR ( dni VARCHAR(10), nom VARCHAR, data_n DATE, parentesc VARCHAR(50), CONSTRAINT cp_fam2 PRIMARY KEY (dni,nom) ) Com coment\u00e0vem, si la clau principal est\u00e0 formada per 2 camps estarem obligats a utilitzar una restricci\u00f3 de camp m\u00faltiple. Un error prou com\u00fa seria el seg\u00fcent: CREATE TABLE FAMILIAR2 ( dni VARCHAR(10) PRIMARY KEY, nom VARCHAR PRIMARY KEY, data_n DATE, parentesc VARCHAR(50) ) Podeu comprovar que donar\u00e0 error , perqu\u00e8 estem intentant definir 2 claus principals. La clau principal \u00e9s \u00fanica, aix\u00f2 s\u00ed formada per 2 camps en aquesta ocasi\u00f3. Restricci\u00f3 d'unicitat UNIQUE : ara posarem entre par\u00e8ntesis el o els camps que seran \u00fanics (en el seu conjunt). PostgreSQL generar\u00e0 autom\u00e0ticament un \u00edndex per a aquesta combinaci\u00f3 de camps. Veurem qu\u00e8 \u00e9s un \u00edndex en la pregunta 6. Per exemple, modifiquem la definici\u00f3 de EMPLEAT3 (anomenant-la EMPLEAT4) , amb un camp per als cognoms i un camp per al nom . Definirem la restricci\u00f3 que els camps cognoms i nom (en conjunt) no es poden repetir. CREATE TABLE EMPLEAT4 ( dni VARCHAR(10), cognoms VARCHAR, nom VARCHAR, data_naixement DATE, sou NUMERIC(6,2) , departament INT2 , CONSTRAINT u_nom4 UNIQUE (cognoms,nom) ) Restricci\u00f3 de valor no nul NOT NULL . No existeix aquesta opci\u00f3 com a restricci\u00f3 m\u00faltiple. Per tant s'ha de definir sempre com a restricci\u00f3 de camp \u00fanic. Restricci\u00f3 d'integritat referencial FOREIGN KEY : servir\u00e0 per a definir que aquest o aquestos camps s\u00f3n una clau externa. \u00c9s la que m\u00e9s varia en la seua sintaxi, ja que hem d'especificar tant el o els camps d'aquesta taula que s\u00f3n clau externa, com la taula a la qual apunta (i en tot cas el o els camps on s'apunta, encara que si no ho posem apuntar\u00e0 a la clau principal de l'altra taula, cosa que voldrem sempre): [CONSTRAINT nom] FOREIGN KEY (c11 [,c12][,...]) REFERENCES taula2 [(c21 [,c22][,...])] [ON DELETE {CASCADE | SET NULL}] [ON UPDATE {CASCADE | SET NULL}] En l'exemple de la clau externa que apunta a la taula DEPARTAMENT quedar\u00e0 aix\u00ed: CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT ce_emp3_dep FOREIGN KEY (departament) REFERENCES DEPARTAMENT ) Restricci\u00f3 externa CHECK : ara la condici\u00f3 de validaci\u00f3 podr\u00e0 afectar a m\u00e9s d'un camp Per exemple podr\u00edem exigir que la data d'incorporaci\u00f3 siga estrictament posterior a la data de naixement CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT check_dates CHECK (data_incorporacio > data_naixement) ) O una altra una miqueta m\u00e9s real, anem a agafar empleats de m\u00e9s de 18 anys, i per tant anem a exigir que la data d'incorporaci\u00f3 siga m\u00e9s de 18 anys posterior a la data de naixement. Per a aix\u00f2 utilitzem la funci\u00f3 AGE(f1,f2) que calcula el temps entre la data d2 i la data d1 (que ha de ser la posterior), i d'ah\u00ed extraurem els anys amb EXTRACT(year FROM ...) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT check_dates CHECK (EXTRACT(year FROM AGE(data_incorporacio,data_naixement) ) >=18 ) ) Evidentment, es poden barrejar les restriccions de camp \u00fanic i les de camp m\u00faltiple. Ac\u00ed en tenim un exemple on s'arrepleguen moltes (no totes) les restriccions anteriors. Hem posat de camp m\u00faltiple la dels 18 anys dels empleats, perqu\u00e8 no hi ha un altre remei, i tamb\u00e9 la de no repetici\u00f3 del camp nom , encara que podia ser de camp \u00fanic: CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY , nom VARCHAR CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT u_nom3 UNIQUE (nom) , CONSTRAINT check_dates CHECK (EXTRACT(year FROM AGE(data_incorporacio,data_naixement) ) >=18 ) ) Exercicis En factura_local : Ex_3 - Crear la taula PROVINCIA , amb la clau principal. Ex_4 - Crear la taula POBLE , amb la clau principal i la restricci\u00f3 que el camp cod_pro \u00e9s clau externa que apunta a PROVINCIA. Ex_5 - Crear la taula VENEDOR , amb la clau principal i la clau externa a POBLE (de moment no definim la clau externa a VENEDOR, que \u00e9s reflexiva). Ex_6 - Crear la taula CLIENT , amb la clau principal i la clau externa a POBLE Ex_7 - Crear la taula FACTURA , amb la clau principal i les claus externes a CLIENT i VENEDOR. Tamb\u00e9 heu d'exigir que cod_cli siga no nul. Ex_8 - Crear la taula LINIA_FAC , amb la clau principal (observa que est\u00e0 formada per 2 camps) per\u00f2 de moment sense la clau externa que apunta a ARTICLE. A m\u00e9s cod_a ha de ser no nul. 2.3 ALTER TABLE Permet modificar l'estructura d'una taula ja existent, b\u00e9 afegint, llevant o modificant camps (columnes), b\u00e9 afegint o llevant restriccions. Tamb\u00e9 servir\u00e0 per a canviar el nom d'un camp i fins i tot canviar el nom de la taula Sintaxi Per a alterar l'estructura d'algun camp o restricci\u00f3 utilitzarem aquesta sintaxi: ALTER TABLE taula {ADD | DROP | ALTER} {COLUMN camp | CONSTRAINT restricci\u00f3 m\u00faltiple} Per a canviar el nom d'un camp: ALTER TABLE taula RENAME [COLUMN] camp TO nou_nom_camp Per a canviar el nom de la taula: ALTER TABLE taula RENAME TO nou_nom_taula Afegir camp o restricci\u00f3 Si volem afegir una columna o una restricci\u00f3, l'haurem de definir totalment. En el cas d'un camp, haurem d'especificar el nom, el tipus i opcionalment una restricci\u00f3 que afecte nom\u00e9s al camp. Per exemple, aquesta sent\u00e8ncia afegeix el camp supervisor (de tipus text de 10) a la taula EMPLEAT3. Observeu que en la definici\u00f3 del camp poden entrar restriccions de camp \u00fanic. ALTER TABLE EMPLEAT3 ADD COLUMN supervisor VARCHAR(10) En el cas d'una restricci\u00f3, aquesta ser\u00e0 del tipus de restricci\u00f3 m\u00faltiple, amb la sintaxi que vam veure en l'apartat de restriccions. Per exemple, aquesta sent\u00e8ncia afegeix la clau externa reflexiva (de EMPLEAT3 a EMPLEAT3) que indica els supervisors. El dni hauria de ser la clau principal de EMPLEAT3 ALTER TABLE EMPLEAT3 ADD CONSTRAINT ce_emp3_emp3 FOREIGN KEY (supervisor) REFERENCES EMPLEAT3 (dni) Modificar un camp Podem fer dues coses: modificar el tipus del camp o modificar el valor per defecte (posar valor per defecte o llevar-lo) Per a canviar el tipus haurem d'utilitzar la sintaxi ... ALTER COLUMN camp TYPE nou_tipus **. Per exemple anem a fer que el camp poblacio siga de 25 car\u00e0cters ALTER TABLE EMPLEAT3 ALTER COLUMN poblacio TYPE VARCHAR(25) Canviar el tipus de dades \u00e9s autom\u00e0tic quan els tipus s\u00f3n compatibles entre ells. Si no ho s\u00f3n ens donar\u00e0 error, per\u00f2 segurament ho podrem esquivar amb la cl\u00e0usula USING , que ens permet posar a continuaci\u00f3 el camp i aprofitem per a posar un operador de conversi\u00f3 de tipus ( :: ) amb aquesta sintaxi : ALTER TABLE _TAULA_ ALTER COLUMN _camp_ TYPE _tipus_nou_ USING _camp_ ::_tipus_nou_ Per a canviar el valor per defecte utilitzarem la sintaxi : **... ALTER COLUMN camp {SET | DROP} DEFAULT [ expressi\u00f3 ] ** ALTER TABLE EMPLEAT3 ALTER COLUMN poblacio DROP DEFAULT Esborrar camp o restricci\u00f3 Si volem llevar un camp o una restricci\u00f3 \u00e9s suficient amb especificar el nom del camp o de la restricci\u00f3 (per aix\u00f2 pot ser molt interessant donar nom a les restriccions). En el primer exemple llevem la clau externa del supervisor. En la segona llevem el camp supervisor. ALTER TABLE EMPLEAT3 DROP CONSTRAINT ce_emp3_emp3; ALTER TABLE EMPLEAT3 DROP COLUMN supervisor Renomenar un camp Per exemple renomenem el camp data_incorporacio a data_inc : ALTER TABLE EMPLEAT3 RENAME COLUMN data_incorporacio TO data_inc Renomenar la taula Ara li posarem el nom EMP3 a la taula EMPLEAT3 ALTER TABLE EMPLEAT3 RENAME TO EMP3 Exemples 1) Modificar la taula EMP3 per afegir el camp cp (codi postal) de tipus text de 5 car\u00e0cters. ALTER TABLE EMP3 ADD COLUMN cp VARCHAR(5); 2) Modificar la taula EMP3 per modificar el camp anterior i que siga de tipus num\u00e8ric. ALTER TABLE EMP3 ALTER COLUMN cp TYPE NUMERIC(5) USING CP::NUMERIC; 3) Modificar la taula EMP3 per afegir la restricci\u00f3 (encara que siga un poc estranya) que no es pot repetir la combinaci\u00f3 codi postal i poblaci\u00f3. ALTER TABLE EMP3 ADD CONSTRAINT u_cp_pobl UNIQUE (cp,poblacio); 4) Modificar la taula EMP3 per esborrar la restricci\u00f3 anterior ALTER TABLE EMP3 DROP CONSTRAINT u_cp_pobl; 5) Modificar la taula EMP3 per modificar el nom del camp cp a codi_postal ALTER TABLE EMP3 RENAME COLUMN cp TO codi_postal; 6) Renomenar la taula EMP3 a EMPLEAT3 ALTER TABLE EMP3 RENAME TO EMPLEAT3; Exercicis En factura_local : Ex_9 - Afegir un camp a la taula VENEDOR anomenat alies de tipus text, que ha de ser no nul i \u00fanic. Ex_10 - Esborrar el camp anterior, alies , de la taula VENEDOR . Ex_11 - Afegir la clau principal de CATEGORIA . Ex_12 - En la taula ARTICLE afegir la clau principal i la clau externa a CATEGORIA. Ex_13 - En la taula LINIA_FAC afegir la clau externa que apunta a FACTURA, exigint que s'esborre en cascada (si s'esborra una factura, s'esborraran autom\u00e0ticament les seues l\u00ednies de factura). I tamb\u00e9 la clau externa que apunta a ARTICLE (aquesta normal, \u00e9s a dir NO ACTION) Nota Per a no fer-lo massa llarg s'han deixat de definir alguna restricci\u00f3, concretament la reflexiva de VENEDOR a VENEDOR (que marca el cap) 2.4 DROP TABLE Ens servir\u00e0 per esborrar absolutament una taula, tant les dades com l'estructura. S'ha d'anar amb compte amb ella, perqu\u00e8 \u00e9s una operaci\u00f3 que no es pot desfer, i per tant potencialment molt perillosa. Sintaxi DROP TABLE taula Exemples DROP TABLE FAMILIAR 2.5 \u00cdndex Els \u00edndex s\u00f3n estructures de dades que permeten mantenir ordenada una taula respecte a un o m\u00e9s d'un camp, cadascun d'ells de forma ascendent o descendent. Tenir un \u00edndex per un determinat camp o camps permet reduir dr\u00e0sticament el temps utilitzat en ordenar per ells (perqu\u00e8 ja es mant\u00e9 aquest ordre) i tamb\u00e9 quan es busca un determinat valor d'aquest camp, ja que com est\u00e0 ordenat es poden fer recerques bin\u00e0ries o dicot\u00f2miques. Quan no est\u00e0 ordenat no hi ha m\u00e9s remei que fer una recerca seq\u00fcencial, que \u00e9s considerablement m\u00e9s lenta. De tota manera no s'ha d'abusar dels \u00edndex, ja que \u00e9s una estructura addicional de dades que ocupar\u00e0 espai, i que com s'han de mantenir els \u00edndex constantment actualitzats, cada vegada que es realitza una operaci\u00f3 d'actualitzaci\u00f3 (inserci\u00f3, modificaci\u00f3 o esborrat) s'ha de reestructurar l'\u00edndex, per a posar o llevar l'element al seu lloc. Creaci\u00f3 d'\u00edndex A banda de la creaci\u00f3 expl\u00edcita d'\u00edndex que farem en aquesta pregunta, PostgreSQL crea impl\u00edcitament un \u00edndex cada vegada que: Creem una clau princpal Creem una restricci\u00f3 d'unicitat (UNIQUE) En ambd\u00f3s casos ser\u00e0 un \u00edndex que no es podr\u00e0 repetir. Per tant, en els casos anteriors no cal crear un \u00edndex, perqu\u00e8 PostgreSQL ja ho ha fet autom\u00e0ticament. En PostgreSQL la creaci\u00f3 d'\u00edndex \u00e9s molt completa. Anem a veure una versi\u00f3 resumida: Sintaxi CREATE [UNIQUE] INDEX nom_\u00edndex ON taula (c1 [ASC|DESC][, c2 [ASC|DESC], ...] [NULLS { FIRST | LAST }] ) Si posem l'opci\u00f3 UNIQUE impedir\u00e0 que es repetisquen els valors del camp (o camps) que formen l'\u00edndex, de forma similar a la restricci\u00f3 UNIQUE del CONSTRAINT. L'opci\u00f3 d'ordenaci\u00f3 per defecte \u00e9s l'ascendent. Podem fer que els nuls estiguen al principi de tot o al final de tot, segons ens convinga: FIRST : far\u00e0 que en l'ordenaci\u00f3, els valors nuls vagen abans de qualsevol altre valor. Aquesta \u00e9s l'opci\u00f3 per defecte, si l'ordre \u00e9s descendent, a m\u00e9s de crear l'\u00edndex fa que siga clau principal. Evidentment no ha d'haver una clau principal creada amb anterioritat. LAST : els valors nuls estaran al final de tot, despr\u00e9s de qualsevol altre valor. \u00c9s l'opci\u00f3 per defecte quan l'ordre \u00e9s ascendent. Exemples 1) Crear un \u00edndex en la taula EMPLEAT4 per al camp departament en ordre ascendent . CREATE INDEX i_dep ON EMPLEAT4 (departament); 2) Crear un index per al camp data_naixement (descendent) i sou (ascendent) en la taula EMPLEAT4 . En els dos casos, data_naixement i sou , s'han d'ordenar els valors nuls al final CREATE INDEX i_dat_sou ON EMPLEAT4 (data_naixement DESC NULLS LAST, sou NULLS LAST); Esborrar un \u00edndex La sent\u00e8ncia d'esborrar un \u00edndex \u00e9s molt senzilla. Nom\u00e9s hem d'especificar el nom de l'\u00edndex i la taula on est\u00e0 definit. DROP INDEX nom_\u00edndex ON taula Exercicis En factura_local : Ex_14 - Afegir un \u00edndex anomenat i_nom_cli a la taula CLIENT pel camp nom . Ex_15 - Afegir un \u00edndex anomenat i_adr_ven a la taula VENEDOR per a que estiga ordenat per cp (ascendent) i adreca (descendent). 2.6 Vistes Les vistes, tamb\u00e9 anomenades esquemes externs, consisteixen en visions particulars de la B.D. Es correspon al nivell extern de l'arquitectura a tres nivells. Les taules, que s\u00f3n les que realment contenen les dades i donen la visi\u00f3 global de la B.D., corresponen al nivell conceptual. Creaci\u00f3 d'una vista Sintaxi CREATE VIEW _nom_vista_ AS _subconsulta_ [WITH READ ONLY]; on se li d\u00f3na un nom, \u00e9s el resultat d'una subconsulta (un SELECT), i tenim la possibilitat d'impedir la modificaci\u00f3 de les dades. Per exemple, una vista amb les comarques, el n\u00famero de poblacions de cada comarca, el total d'habitats i l'altura mitjana: CREATE OR REPLACE VIEW ESTADISTICA AS SELECT nom_c, count(nom) AS num_p,sum(poblacio) AS pobl, avg(altura) AS alt_mitjana FROM POBLACIONS GROUP BY nom_c ORDER BY nom_c; Nota Si voleu provar aquesta vista, ho podeu fer en la Base de Dades geo , ja que en ella tenim dades per a la consulta que proporciona les dades a la vista. Recordeu que ens estem connectant tots com el mateix usuari, per tant si alg\u00fa ha creat un objecte (en aquest cas una vista) no es podr\u00e0 utilitzar aquest nom per a crear un altre objecte. Per aix\u00f2 \u00e9s convenient que si feu una prova de crear un objecte, despr\u00e9s esborreu aquest objecte. Observeu la sintaxi CREATE OR REPLACE, que va molt b\u00e9 per a crear, i si ja existeix per a substituir. Com que estem accedint tots com el mateix usuari, ser\u00e0 prou normal que l'objecte ja existesca per haver-lo creat un company. D'aquesta manera el substituirem. No passa res per esborrar un objecte ja existent, ja que tot a\u00e7\u00f2 s\u00f3n proves. La manera d'utilitzar-la \u00e9s com una taula normal, per\u00f2 ja sabem, que en realitat les dades estan en les taules. SELECT * FROM ESTADISTICA; I fins i tot es pot jugar amb taules i vistes. En aquesta sent\u00e8ncia traurem la prov\u00edncia, nom de la comarca, n\u00famero de pobles i altura mitjana de les comarques amb 5 o menys pobles: SELECT provincia,COMARQUES.nom_c,num_p,alt_mitjana FROM COMARQUES , ESTADISTICA WHERE COMARQUES.nom_c=ESTADISTICA.nom_c and num_p <= 5; Esborrar una vista Per a esborrar una vista DROP VIEW _nom_vista_ Per exemple, per a esborrar la vista anterior:a esborrar una vista DROP VIEW ESTADISTICA; Exercicis En factura_local : Ex_16 - Crear la vista RESUM_FACTURA , que ens d\u00f3ne el total dels diners de la factura, el total despr\u00e9s del descompte d'articles, i el total despr\u00e9s del descompte de la factura, tal i com ten\u00edem en la consulta Ex_56 . A partir d'aquest moment podrem utilitzar la vista per a traure aquestos resultats Ex 17 - Crear la vista RESUM_VENEDOR , on aparega informaci\u00f3 del nom del venedor, del nombre total d'articles venuts i de l'import total facturat. Ex 18 - Crear la vista RESUM_CATEGORIAS , on aparega informaci\u00f3 del nom de la categoria, del nombre total d'articles venuts i de l'import total facturat. 2.7. Creaci\u00f3 d'altres objectes: seq\u00fc\u00e8ncies, dominis i tipus. Una de les caracter\u00edstiques de PostgreSQL \u00e9s la seua gran versatilitat. En concret es poden crear molts objectes. A banda dels habituals, vistes, seq\u00fc\u00e8ncies,... es poden xcrear m\u00e9s tipus d'objectes. En aquest curs donarem una ulladeta als dominis i la definici\u00f3 de nous tipus de dades. Hem de tenir en consideraci\u00f3 que tots ens connectarem com el mateix usuari per a fer proves. Per tant els objectes que creem poden fastidiar a altres companys si utilitzem tots els mateixos noms. En altres SGBD (com per exemple Oracle) existeix la possibilitat de crear els objectes posant CREATE OR REPLACE ... , que si no existeix el crea, i si existeix el substitueix. Lamentablement en PostgreSQL dep\u00e9n de la versi\u00f3: en les m\u00e9s modernes s\u00ed que es pot, per\u00f2 en versions anteriors no podrem, excepte en les vistes i les funcions. 2.7.1 Seq\u00fc\u00e8ncies Creaci\u00f3 d'una seq\u00fc\u00e8ncia Tamb\u00e9 es poden crear seq\u00fc\u00e8ncies ( SEQUENCE ), que s\u00f3n objectes que agafen valors num\u00e8rics que van incrementant-se (com l'autonum\u00e8ric). Sintaxi CREATE SEQUENCE _nom_seq\u00fc\u00e8ncia_ [START WITH _valor_inicial_] [INCREMENT BY _valor_increment_] ... ; La sent\u00e8ncia \u00e9s m\u00e9s llarga, per a considerar m\u00e9s casos. Per a nosaltres est\u00e0 b\u00e9 aix\u00ed. Per defecte, el valor inicial \u00e9s 1, i l'increment tamb\u00e9 1. \u00c9s un objecte independent de les taules. S'utilitza de la seg\u00fcent manera: CURRVAL(' nom_seq\u00fc\u00e8ncia ') torna el valor actual (ha d'estar inicialitzat) NEXTVAL(' nom_seq\u00fc\u00e8ncia ') incrementa la seq\u00fc\u00e8ncia i torna el nou valor (excepte la primera vegada que l'inicia amb el valor inicial) La manera habitual d'utilitzar-lo ser\u00e0 per obtenir un valor que s'afegir\u00e0 a un camp d'una taula (normalment la clau principal). Suposem que tenim una taula anomenada FACTURA amb l'estructura que ve a continuaci\u00f3, i volem que la clau principal siga un autonum\u00e8ric. Ho podem provar sobre la Base de Dades i usuari proves . CREATE TABLE FACTURA ( num_f NUMERIC(7) CONSTRAINT cp_fact PRIMARY KEY, data DATE, client VARCHAR(10)); Primer ens crearem la seq\u00fc\u00e8ncia: CREATE SEQUENCE s_num_fac START WITH 2016001; Despr\u00e9s l'utilitzem: INSERT INTO FACTURA VALUES (NEXTVAL('s_num_fac'), '15-01-2016','cli001'); Si ara mirem el contingut de la taula FACTURA obtindrem: O fins i tot en el moment de declarar la taula, li posem un valor per defecte al camp, que ser\u00e0 el seg\u00fcent de la seq\u00fc\u00e8ncia. No haurem d'introduir ara res en la columna num_f , que agafa el valor de la seq\u00fc\u00e8ncia CREATE TABLE FACTURA2 ( num_f NUMERIC(7) CONSTRAINT cp_fact2 PRIMARY KEY DEFAULT NEXTVAL('s_num_fac'), data DATE, client VARCHAR(10)); INSERT INTO FACTURA2(data,client) VALUES ('15-01-2016','cli001'); Observeu tamb\u00e9 que en la taula FACTURA2, el valor comen\u00e7a per 2016002 , ja que el primer valor l'hav\u00edem utilitzat en FACTURA. Per tant el contingut de la taula FACTURA2 ser\u00e0: Tamb\u00e9 ho podr\u00edem haver fet declarant la clau de tipus SERIAL , que el que fa \u00e9s implementar una seq\u00fc\u00e8ncia, i donar valors successius per al camp on est\u00e0 definida. Per\u00f2 d'aquesta manera la seq\u00fc\u00e8ncia comen\u00e7a sempre per 1 CREATE TABLE FACTURA3 ( num_f SERIAL CONSTRAINT cp_fact3 PRIMARY KEY, data DATE, client VARCHAR(10)); I despr\u00e9s fer la inserci\u00f3 d'aquesta manera: INSERT INTO FACTURA3(data,client) VALUES ('15-01-2016','cli001') Com coment\u00e0vem, el valor introdu\u00eft per la seq\u00fc\u00e8ncia ser\u00e0 1 : Tornarem a veure aquest exemple en les consultes d'actualitzaci\u00f3, concretament el INSERT . Esborrar una seq\u00fc\u00e8ncia Per a esborrar una seq\u00fc\u00e8ncia utilitzarem la sent\u00e8ncia DROP SEQUENCE : DROP SEQUENCE s_num_fac De moment aquesta sent\u00e8ncia ens donaria error, ja que la taula FACTURA2 utilitza aquesta seq\u00fc\u00e8ncia. Esborrarem primer les 3 taules, i despr\u00e9s la seq\u00fc\u00e8ncia per a no interferir amb els companys/es. DROP TABLE FACTURA, FACTURA2, FACTURA3; DROP SEQUENCE s_num_fac; 2.7.2 Dominis Els dominis s\u00f3n els conjunts de valors que pot agafar un determinat camp. Habitualment es posa senzillament un tipus de dades. Per\u00f2 el model relacional te\u00f2ric \u00e9s m\u00e9s restrictiu, i els dominis encara podrien ser subconjunts d'aquestos tipus de dades. Creaci\u00f3 d'un domini Normalment aquestos subconjunts es realitzen per mig dels check , que permeten una regla de validaci\u00f3 (una condici\u00f3) per a donar les dades com a bones (per exemple, un sou sempre \u00e9s positiu, per tant, a banda de fer que siga num\u00e8ric podr\u00edem obligar a que f\u00f3ra positiu). Sintaxi CREATE DOMAIN nom AS data_tipus [CHECK(expresi\u00f3)| NOT NULL | NULL ]; PostgreSQL permet definir dominis, que seran d'un determinat tipus base, d'una grand\u00e0ria determinada (opcional), amb un valor per defecte (opcional) i fins i tot amb una cl\u00e0usula check . A partir d'aquest moment, un o m\u00e9s d'un camp els podrem definir d'aquest domini (amb l'avantatge que canviant el domini canviem el tipus de tots els camps que el tenen). Anem a veure alguns exemples que es poden realitzar sobre l'usuari proves . CREATE DOMAIN sou AS numeric(7,2) CHECK (VALUE > 0); Si us d\u00f3na error perqu\u00e8 ja existia el domini, senzillament esborreu el domini anterior i ho torneu a provar Ara podr\u00edem definir la taula: CREATE TABLE EMPLEAT5 ( cod_e varchar(5) primary key, nom_e varchar(50), salari sou); Si intentem introduir la dada del sou malament (per exemple posant-lo negatiu) veurem que d\u00f3na error. Un altre exemple, que farem sobre la Base de Dades proves , encara que \u00e9s un exemple basat en les taules que ten\u00edem en geo . En la taula de POBLACIONS tenim les coordenades ( latitud i longitud ). Podr\u00edem intentar fer uns dominis per a marcar l' hemisferi (N S per a latitud, i E W per a longitud), els graus de latitud (-90\u00ba a 90\u00ba), graus de longitud (-180\u00ba a 180\u00ba) en longitud, per als minuts (0' a 59') , segons (0\u201d a 59\u201d). Centrem-nos en la latitud: CREATE DOMAIN hemi_lat AS char(1) CHECK (VALUE IN ('N','S')); CREATE DOMAIN graus_lat AS numeric(2) CHECK (VALUE BETWEEN 0 AND 90); CREATE DOMAIN min_seg AS numeric(2) CHECK (VALUE BETWEEN 0 AND 59); Ara podr\u00edem definir una alternativa a la taula de POBLACIONS: CREATE TABLE POBLACIONS2 ( nom VARCHAR(50) CONSTRAINT cp_pob2 PRIMARY KEY, lat_h hemi_lat, lat_g graus_lat, lat_m min_seg, lat_s min_seg); i comprovar\u00edem que les latituds s'han d'introduir correctament. Si posem per exemple els minuts malament, d\u00f3na error INSERT INTO POBLACIONS2 VALUES('Illes Columbretes','N',39,73,57); Per\u00f2 no hi ha problema si les dades s\u00f3n correctes. INSERT INTO POBLACIONS2 VALUES('Illes Columbretes','N',39,53,57); Esborrar un domini Per a esborrar un domini, utilitzarem DROP DOMAIN. Sintaxi DROP DOMAIN [IF EXISTS] nom [CASCADE | RESTRICT] RESTRICT rebutja eliminar el domini si hi ha objectes que depenen d'ell. Aquest \u00e9s el valor predeterminat. Exemple DROP DOMAIN sou; Si algun camp est\u00e0 definit amb el domini que esborrem, donar\u00e0 error. Si esborr\u00e0rem amb l'opci\u00f3 CASCADE, s'esborrarien els camps de les taules amb aquest domini. Per a deixar que els companys/es puguen treballar tamb\u00e9, esborrem tot el que hem creat: DROP TABLE EMPLEAT5; DROP DOMAIN sou; Encara no esborrem els dominis hemi_lat , graus_lat i min_seg , perqu\u00e8 els utilitzarem en la seg\u00fcent pregunta. 2.7.3 Tipus de dades Ja hav\u00edem comentat que PosgreSQL \u00e9s molt vers\u00e0til, i permet a l'usuari crear tipus de dades personals. Tres s\u00f3n les maneres de crear un tipus de dades: compost, enumerat i extern. Compost \u00e9s com un registre, on s'especifiquen els camps i els tipus. Enumenat : posarem els possibles valors entre par\u00e8ntesis. Extern \u00e9s molt m\u00e9s complet i complex que permet crear un nou tipus base, amb una estructura interna i amb funcions, normalment creades en C, d'entrada (per a introduir la dada) i eixida (per a representar-la), d'an\u00e0lisi, ... Aquest tipus s'escapa dels objectius d'aquest curs Creaci\u00f3 de tipus de data Compost Sintaxi Posarem entre par\u00e8ntesi el nom dels camps i el tipus que formaran part d'aquest tipus compost. CREATE TYPE nom AS ([nom_camp tipo_camp] [,..]) Exemple Per exemple, sobre la Base de Dades proves : CREATE TYPE num_complex AS (a float4, b float4); que ens serviria per a representar n\u00fameros complexes. Si us d\u00f3na error perqu\u00e8 ja existieix el tipus (perqu\u00e8 l'ha creat un company/a), senzillament esborreu- lo abans i ho torneu a provar Un altre exemple (no cal fer-lo, \u00e9s il\u00b7lustratiu nom\u00e9s): CREATE TYPE lat AS ( h char(1), g numeric(2,0), m numeric(2,0), s numeric(2,0)); per a representar la latitud, encara que podr\u00edem aprofitar els dominis creats en el punt anterior, i ens eixir\u00e0 millor (aquest s\u00ed que el podeu fer): CREATE TYPE lat AS ( h hemi_lat, g graus_lat, m min_seg, s min_seg); i el tipus lat haur\u00e0 de respectar les restriccions de cada domini dels quatre camps. Ara podr\u00edem definir una taula CREATE TABLE POBLACIONS3 ( nom VARCHAR(50) CONSTRAINT cp_pob3 PRIMARY KEY, latitud lat, comarca varchar(50)); D'aquesta manera queda molt compacte. Per exemple, aquesta introducci\u00f3 de dades donar\u00e0 un error, ja que l'hemisferi no \u00e9s correcte: INSERT INTO POBLACIONS3 VALUES ('Castell\u00f3','(K,39,59,10)','Plana Alta'); En canvi aquesta funcionar\u00e0 perfectament: INSERT INTO POBLACIONS3 VALUES ('Castell\u00f3','(N,39,59,10)','Plana Alta'); Per a accedir als camps dels tipus compostos, b\u00e9 ja definits, b\u00e9 definits per nosaltres, haurem de posar el nom de la columna seguida d'un punt i seguit del nom del camp. Per\u00f2 en les sent\u00e8ncies SQL se'ns presenta un problema: que aquesta sintaxi serveix per a posar tamb\u00e9 el nom de la taula seguit del nom de la columna. Aix\u00ed per exemple ens donar\u00e0 error la seg\u00fcent sent\u00e8ncia, en la que volem traure el nom de la poblaci\u00f3, la latitud i si est\u00e0 en l'hemisferi nord o sud: SELECT nom, latitud, latitud.h FROM POBLACIONS3; L'error el d\u00f3na perqu\u00e8 en latitud.h espera que latitud siga una taula i h una columna. La manera d'esquivar aquest error \u00e9s posar entre par\u00e8ntesis la columna: SELECT nom, latitud, (latitud).h FROM POBLACIONS3; En el tema seg\u00fcent, el de programaci\u00f3 en PL/pgSQL veurem que all\u00e0 no caldr\u00e0 posar els par\u00e8ntesis, perqu\u00e8 no hi haur\u00e0 la confusi\u00f3 de taula.columna Creaci\u00f3 de tipus de data Enumerat El tipus enumerat \u00e9s un conjunt de dades est\u00e0tiques definides en el moment de la creaci\u00f3 del tipus, amb un ordre tamb\u00e9 predefinit. Est\u00e0 disponible des de la versi\u00f3 8.3 de PostgreSQL. Sintaxi CREATE TYPE nom AS ENUM ('element' [,...]) Exemple CREATE TYPE d_set AS ENUM ('dilluns','dimarts','dimecres','dijous','divendres','dissabte','diumenge'); Posteriorment el podrem utilitzar, per exemple, en la definici\u00f3 d'una taula: CREATE TABLE HORARI ( cod_pr NUMERIC(5) PRIMARY KEY, d_tut d_set, h_tut NUMERIC(4,2)); Ara el podem utilitzar. Haurem de tenir en compte que els valors s\u00f3n \u00fanicament els definits. I s'ha de respectar maj\u00fascules i minuscules. INSERT INTO HORARI VALUES (1,'dimarts',10); En canvi, aquesta donaria error : INSERT INTO HORARI VALUES (2,'Dimecres',12); ja que el nom de la setmana comen\u00e7a en maj\u00fascula. Introdu\u00efm algunes dades m\u00e9s INSERT INTO HORARI VALUES (2, 'dimecres',12) , (3,'dilluns',9) , (4,'divendres',11); Podem comprovar com l'ordre predefint \u00e9s el del moment de la creaci\u00f3 del tipus: SELECT * FROM HORARI ORDER BY d_tut; I com tamb\u00e9 es pot comprovar en aquesta sent\u00e8ncia: SELECT * FROM HORARI WHERE d_tut > 'dimarts'; on nom\u00e9s eixiran les files corresponents al dimecres i al divendres (files 2 i 4). Esborrar tipus de dades Per \u00faltim, anem a esborrar els objectes que hem creat, per a no interferir amb els companys: DROP TABLE POBLACIONS2 , POBLACIONS3 , HORARI ; DROP TYPE num_complex , lat , d_set ; DROP DOMAIN hemi_lat , graus_lat , min_seg ; Exercicis En factura_local : Ex 19 - Tenim creada la taula VENEDOR i es desitja que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica personalitzada. Observa la informaci\u00f3 actual en la taula VENEDOR de la BD factura i analitza quina seq\u00fc\u00e8ncia s'ha utilitzat. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte la seq\u00fc\u00e8ncia creada, per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat Ex 20 - Volem crear una nova taula CLIENT2 i es vol que la clau principal siga una seq\u00fc\u00e8ncia personalitzada autonumerica. Observa la informaci\u00f3 actual en la taula CLIENT de la BD factura i analitza quina seq\u00fc\u00e8ncia s'hauria de utilitzat. Has de tindre en compte que al crear la taula CLIENT2 perqu\u00e8 el camp cod_cli, per defecte sempre agafe el valor seg\u00fcent de la seq\u00fc\u00e8ncia definida anteriorment. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte els canvis realitzats en la base de dades. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 21 - En la taula FACTURA2 es vol que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica en s\u00e8rie. Crea la taula FACTURA2 perqu\u00e8 el camp num_f utilitze una seq\u00fc\u00e8ncia en s\u00e8rie. A m\u00e9s has de tindre en compte que el iva de la factura solament pot ser el 10 o el 21 i que el descompte la factura ha de ser inferior a 50. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 22 - Crea la taula ARTICLE2 tenint en compte el seg\u00fcent; Comprovar que el preu, stock i stock_min no \u00e9s negatiu Crear un tipus de dades per a l'estat d'un article, que pot prendre els valors \"Disponible\", \"Esgotat\" o \"En espera\". Crea un tipus de dada per a registrar el codi de barres EAN-13 d'un article. Tenint en compte que el codi de barres EAN-13 s'observen 3 parts: Pa\u00eds de proced\u00e8ncia: s\u00f3n els dos o tres primers d\u00edgits i, en el cas d'Espanya, aquest prefix \u00e9s el 84. Codi del producte: seg\u00fcents 9 o 10 d\u00edgits. D\u00edgit de control: \u00e9s un sol n\u00famero, l'\u00faltim, i serveix per a corroborar que el codi \u00e9s correcte. Comprovar que stock no pot ser inferior a stock _min (HAS DE DEFINIR UNA CONSTRAINT) A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona.. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2. DDL"},{"location":"2_ddl/#2-ddl","text":"DDL ( Data Definition Language ) o Llenguatge de Definici\u00f3 de Dades \u00e9s el conjunt de sent\u00e8ncies que ens permeten definir, retocar o esborrar l'estructura de la Base de Dades. I com que l'estructura b\u00e0sica d'una Base de Dades Relacional \u00e9s la taula, ens dedicarem b\u00e0sicament a estudiar les sent\u00e8ncies que ens permeten definir les taules (o modificar-les o esborrar- les), amb totes les restriccions que hem vist en el Model Relacional: clau principal, claus externes, camps no nuls, ... Tamb\u00e9 veurem altres objectes que podrem definir, sobretot vistes , que es corresponen a l'esquema extern que vam veure en el Tema 1, \u00e9s a dir, la visi\u00f3 particular que pot tenir un usuari. Seran 3 sent\u00e8ncies les que veurem: CREATE , que permet crear un objecte nou. DROP , que permet esborrar un objecte ja existent. ALTER , que permet modificar un objecte ja existent. En el moment de crear una taula definirem tots els seus camps, amb les restriccions pertinents a cadascun d'ells. Cada camp haur\u00e0 de ser d'un tipus de dades. En cada SGBD hi ha uns tipus de dades particulars, encara que els m\u00e9s b\u00e0sics s\u00f3n similars, i en ells ser\u00e0 on incidirem m\u00e9s.","title":"2. DDL"},{"location":"2_ddl/#21-tipus-de-dades","text":"En el moment de definir un camp haurem d'especificar obligat\u00f2riament de quin tipus ser\u00e0. Ja es van veure els tipus b\u00e0sics d'Access en el tutorial del tema 5. Ara els veurem els tipus b\u00e0sics de PostgreSQL , i veurem que hi haur\u00e0 molts tipus similars (com en tots els SGBD). En el seg\u00fcent quadre es resumeixen els tipus de dades m\u00e9s importants de PostgreSQL. \u00c9s un conjunt molt extens, que fins i tot pot ampliar l'usuari amb la instrucci\u00f3 CREATE TYPE , com veurem al final del tema. S\u00f3n especialment interessants els tipus geom\u00e8trics (amb POINT , BOX ,...) i el INET (adre\u00e7a IP). Tamb\u00e9 disposarem d'un tipus enumerat. El veurem en l'\u00faltima pregunta del tema. En la documentaci\u00f3 de PostgreSQL trobarem tots els tipus possibles: http://www.postgresql.org/docs/9.5/static/datatype.html","title":"2.1 Tipus de dades"},{"location":"2_ddl/#22-create-table","text":"Permet crear una nova taula. Obligat\u00f2riament s'hauran d'especificar els camps i els tipus de dades de cada camp. \u00d2bviament, una vegada creada la taula estar\u00e0 buida, sense cap fila. Sintaxi CREATE TABLE taula ( camp1 tipus [(grand\u00e0ria)] [DEFAULT valor] [restricci\u00f311] [restricci\u00f312] [...] [, camp2 tipus [(grand\u00e0ria)] [DEFAULT valor] [restricci\u00f321] [restricci\u00f322][...] [, ...]] [, restricci\u00f3multiple1 [, ...]] ) Podem observar que la definici\u00f3 de l'estructura de la taula va entre par\u00e8ntesis, separant per comes la definici\u00f3 de cada camp. El nom de la taula no ha de ser el de cap altre objecte anterior (taula o vista). Si volem posar un nom amb m\u00e9s d'una paraula o amb una paraula reservada, l'haurem de posar entre cometes dobles; per\u00f2 no us ho aconselle, \u00e9s preferible la utilitzaci\u00f3 del gui\u00f3 baix, i aix\u00ed nom\u00e9s \u00e9s una paraula. En cada camp posarem el seu nom i el tipus. Si el tipus de dades \u00e9s VARCHAR, podrem posar opcionalment la grand\u00e0ria m\u00e0xima (si no la posem ser\u00e0 de 255 en el cas de text). Si el tipus de dades \u00e9s NUMERIC, podrem posar opcionalment la grand\u00e0ria (n\u00famero de xifres significatives) i n\u00famero de xifres de la part fraccion\u00e0ria. Podem posar ocionalment un valor per defecte amb la cl\u00e0usula DEFAULT . D'aquesta manera, en introduir una nova fila en la taula, si no li posem valor a aquest camp, agafar\u00e0 el valor per defecte. En el valor es pot posar una constant del tipus del camp, o una expressi\u00f3 amb funcions, sempre que torne una dada dels tipus del camp. Podem posar opcionalment restriccions a cada camp. Hauran d'anar abans de la coma que separa del seg\u00fcent camp. Tamb\u00e9 poden haver restriccions que afecten a m\u00e9s d'un camp, que preferiblement posarem al final de la definici\u00f3 de la taula. Veurem les restriccions en el seg\u00fcent punt. Exemples Si voleu practicar aquestos exemples, feu-lo sobre la Base de Dades proves (usuari proves , contrasenya proves ). Si us d\u00f3na error perqu\u00e8 la taula que aneu a crear ja est\u00e0 creada la taula, esborreu-la primer, i torneu a executar la sent\u00e8ncia. 1) Crear una nova taula anomenada EMPLEAT1 amb dos camps, un anomenat dni de tipus text i llarg\u00e0ria 10 i un altre anomenat nom * * amb llarg\u00e0ria 50. CREATE TABLE EMPLEAT1 (dni VARCHAR (10) , nom VARCHAR (50)); 2) Crear una taula anomenada EMPLEAT2 amb un camp text de 10 car\u00e0cters anomenat dni ; un altre camp de tipus text de llarg\u00e0ria predeterminada (255) anomenat nom; un altre camp anomenat data_naixement de tipus data; un altre anomenat sou de tipus num\u00e8ric, amb 6 xifres significatives, de les quals 2 ha de ser de la part fraccion\u00e0ria i un \u00faltim anomenat departament de tipus num\u00e8ric menudet (INT2 o SMALLINT). CREATE TABLE EMPLEAT2 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 ) 3) Crear una taula anomenada EMPLEAT3 com el de l'exemple anterior, per\u00f2 amb dos camps m\u00e9s al final: un camp anomenat poblacio de tipus text de 50 car\u00e0cters, i amb el valor per defecte Castell\u00f3 i un \u00faltim anomenat data_incorporacio de tipus data i valor per defecte la data d'avui CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE )","title":"2.2 CREATE TABLE"},{"location":"2_ddl/#exercicis","text":"Al llarg d'aquesta tercera part, en el conjunt d'exercicis de DDL, crearem tota l'estructura de la Base de Dades FACTURA , per\u00f2 per a no interferir cadasc\u00fa amb els altres companys, cadasc\u00fa es connectar\u00e0 a la seua Base de Dades factura_local . L'esquema Entitat-Relaci\u00f3 i l'esquema relacional que implementarem ser\u00e0 el seg\u00fcent: En la Base de Dades anomenada factura_local : Ex_1 - Creeu la taula CATEGORIA , amb els mateixos camps i del mateix tipus que en la taula CATEGORIA de FACTURA , per\u00f2 de moment sense clau principal ni cap altra restricci\u00f3. Ex_2 - Creeu la taula ARTICLE , tamb\u00e9 sense restriccions. Nota Durant tots aquestos exercicis de DDL pot ser molt convenient tenir obertes les dues connexions: la de FACTURA (per anar consultant) i la de factura_local (per anar creant i modificant).","title":"Exercicis"},{"location":"2_ddl/#221-restriccions-constraint","text":"Per mig de les restriccions podrem definir dins d'una taula restriccions d'usuari com s\u00f3n la definici\u00f3 de la clau principal, claus externes, camps no nuls i camps \u00fanics. Hi ha dues maneres de definir restriccions: les que afecten a un \u00fanic camp (i que es posen en la mateixa definici\u00f3 del camp) i les que afecten o poden afectar a m\u00e9s d'un camp, que s'han de definir separadament de la definici\u00f3 dels camps. Comencem per les primeres, per ser m\u00e9s senzilles d'entendre:","title":"2.2.1 Restriccions (Constraint)"},{"location":"2_ddl/#2211-restriccions-de-camp-unic","text":"S\u00f3n restriccions que es posen en la mateixa definici\u00f3 del camp i nom\u00e9s afectaran a aquest camp: van per tant despr\u00e9s del tipus de dades del camp i abans de la coma de separaci\u00f3 dels camps. Sintaxi [ CONSTRAINT nom ] {PRIMARY KEY | UNIQUE | NOT NULL | REFERENCES taula2 [(camp1)] | CHECK (_condici\u00f3_)} Si no posem nom a la restricci\u00f3 (CONSTRAINT nom) PostgreSQL li assignar\u00e0 autom\u00e0ticament un nom. A\u00e7\u00f2 pot resultar c\u00f2mode en ocasions, per a no haver d'inventar-nos noms per a les restriccions, per\u00f2 despr\u00e9s ens limitaria a que no podr\u00edem retocar aquestes restriccions. Els tipus de restriccions que podem definir s\u00f3n: Restricci\u00f3 de clau principal PRIMARY KEY : el camp ser\u00e0 clau principal. Per exemple, d'aquesta manera definirem la taula EMPLEAT3 (com la de l'apartat anterior) amb el camp dni com a clau principal. Recordeu que l'heu d'esborrar primer (potser no l'estigueu visualitzant, per\u00f2 s\u00ed que est\u00e0 creada; refresqueu constantment les taules per saber la situaci\u00f3 actual) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY, nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Nota Podeu comprovar que, si no poseu nom a la restrici\u00f3, \u00e9s a dir, si poseu directament dni TEXT(10) PRIMARY KEY , i aneu al disseny de la taula, PostgreSQL posa autom\u00e0ticament un nom a la restricci\u00f3 format pel nom de la taula seguit de _pkey . Tingueu en compte tamb\u00e9 que si la taula ja existia donar\u00e0 un error. Nom\u00e9s heu d'esborrar-la primer. Restricci\u00f3 d'unicitat UNIQUE : el camp ser\u00e0 \u00fanic, \u00e9s a dir, no es podr\u00e0 agafar dues vegades el mateix valor en aquest camp ( Indexat sense duplicats en Access). PostgreSQL generar\u00e0 autom\u00e0ticament un \u00edndex per a aquest camp. Veurem qu\u00e8 \u00e9s un \u00edndex en la pregunta 6. Per exemple, d'aquesta manera definir\u00edem la taula EMPLEAT3 amb la restricci\u00f3 que el camp nom no es pot repetir (si voleu provar la sent\u00e8ncia feu-lo en la BD proves , i si ja existeix l'esborreu primer): CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR CONSTRAINT u_nom UNIQUE, data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Restricci\u00f3 de valor no nul NOT NULL : el camp no podr\u00e0 agafar un valor nul ( Requerido en Access). Hem de ser conscients que no val la pena definir com a no nula la clau principal, ja que per definici\u00f3 ja ho \u00e9s. Per exemple, d'aquesta manera definirem que el camp nom ha de ser no nul. CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Restricci\u00f3 d'integritat referencial REFERENCES : servir\u00e0 per a definir que aquest camp \u00e9s una clau externa. Haurem d'especificar obligat\u00f2riament la taula a la qual apunta, i opcionalment podem posar entre par\u00e8ntesis el camp de la taula al qual apunta, encara que si no ho posem, per defecte apuntar\u00e0 a la clau principal (i nosaltres sempre voldrem apuntar a la clau principal). Per exemple, d'aquesta manera podem definir la clau externa que apunta a la taula DEPARTAMENT (i que indica que l'empleat pertany al departament). Abans de crear aquesta versi\u00f3 de EMPLEAT3, hem de tenir creada la taula DEPARTAMENT, sin\u00f3 donar\u00e0 error: CREATE TABLE DEPARTAMENT ( num_d INT2 CONSTRAINT cp_dep PRIMARY KEY , nom_d VARCHAR(50) , director VARCHAR(10) , data DATE ); CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ); Com ja es va veure en el tema del Model Relacional (restriccions d'integritat referencial), hi ha 3 maneres d'actuar quan s'esborra o es modifica una fila de la taula principal que t\u00e9 associades files en la taula relacionada per mig de la clau externa. Per exemple, qu\u00e8 fem amb els familiars d'un empleat si esborrem l'empleat? Aquestes maneres d'actuar s'han d'especificar en el moment de definir la clau externa. La manera de posar-les en SQL i el significat s\u00f3n les seg\u00fcents: NO ACTION : no es deixar\u00e0 esborrar o modificar de la taula principal si en t\u00e9 alguna fila relacionada. \u00c9s l'opci\u00f3 per defecte. Aix\u00ed en l'exemple d'EMPLEAT3, amb una clau externa que apunta a DEPARTAMENT, si intentem esborrar o modificar el numero d'un departament que t\u00e9 empleats, ens donar\u00e0 un missatge d'error, avisant que com t\u00e9 registres relacionats en una altra taula no es pot esborrar o modificar. CASCADE : s'esborraran (o modificaran) en cascada els registres relacionats de la taula on est\u00e0 la clau externa. S'especificar\u00e0 amb ON DELETE CASCADE o ON UPDATE CASCADE . CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT ON DELETE CASCADE ON UPDATE CASCADE , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) D'aquesta manera si esborrem un departament de la taula DEPARTAMENT, s'esborraran tamb\u00e9 els empleats de la taula EMPLEATS3 d'aquest departament. I si en la taula DEPARTAMENT modifiquem un n\u00famero de departament, per exemple de 5 a 50, aquest valor ser\u00e0 el nou valor en el camp departament de la taula EMPLEAT3 per a aquells que abans ten\u00eden un 5. SET NULL : posar\u00e0 a nul el camp que \u00e9s clau externa dels registres que estiguen relacionats amb l'esborrat o modificat de la taula principal. Aix\u00ed, si f\u00e9rem la seg\u00fcent definici\u00f3 de la taula EMPLEAT3 CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT ON DELETE SET NULL , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) en el cas que esborrem el departament 5, no donaria cap error per aquesta restricci\u00f3 d'integritat, i posaria a nul el departament d'aquells empleats que abans eren del departament 5. SET DEFAULT : Estableix les columnes que referencien als seus valors per defecte. Ha d'existir una fila en la taula referenicada que coincidixca amb els valors per defecte, si no s\u00f3n NULL, o l'opraci\u00f3 fallar\u00e0. Restricci\u00f3 externa CHECK : far\u00e0 una comprovaci\u00f3 per a validar els valors introdu\u00efts per a aquest camp. La condici\u00f3 de validaci\u00f3 ha d'anar entre par\u00e8ntesis, i ha de ser una expressi\u00f3, normalment de comparaci\u00f3 del camp en q\u00fcesti\u00f3 amb algun valor. Per exemple, anem a exigir que el sou siga estrictament positiu (per tipus de dades num\u00e8ric, podria agafar el valor 0 o valors negatius) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0), departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Evidentment es pot posar m\u00e9s d'una restricci\u00f3 en la definici\u00f3 d'una taula. En aquest exemple arrepleguem totes les anteriors, \u00e9s a dir, definim la taula EMPLEAT3 amb tots els seus camps, i definint la clau principal ( dni ), amb el camp nom \u00fanic , amb el sou estrictament positiu , i amb el camp departament que ser\u00e0 clau externa que apunta a la taula DEPARTAMENT. Per complicar-lo un poc m\u00e9s tamb\u00e9 exigirem que el camp nom siga no nul , i aix\u00ed veure que es pot posar m\u00e9s d'una restricci\u00f3 en un camp. CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY , nom VARCHAR CONSTRAINT u_nom UNIQUE CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE ) Observeu que com a q\u00fcesti\u00f3 d'estil s'han posat noms a les restriccions que d'alguna manera suggereixen el motiu de la restricci\u00f3. Aix\u00ed, cp_emp3 vol dir clau princpal de EMPLEAT3 , u_nom vol dir que el camp nom \u00e9s \u00fanic , nn_nom vol dir que nom \u00e9s no nul , nn_sou vol dir que sou \u00e9s no nul , i ce_emp3_dep vol dir clau externa de la taula EMPLEAT3 a la taula DEPARTAMENT . Si tenim un criteri clar per als noms de les restriccions, si despr\u00e9s les volem desactivar temporalment o senzillament esborrar-les, ho podrem fer des de SQL.","title":"2.2.1.1 Restriccions de camp \u00fanic"},{"location":"2_ddl/#2212-restriccions-de-camp-multiple","text":"Tamb\u00e9 s'anomenen restriccions de taula, en contraposici\u00f3 a les anteriors, que s\u00f3n restriccions de camp. S\u00f3n restriccions que van dins de la definici\u00f3 d'una taula per\u00f2 fora de la definici\u00f3 d'un camp, i que poden afectar a un o m\u00e9s d'un camp. S'haur\u00e0 de definir expressament a quin o quins camps afecten. Sintaxi [ CONSTRAINT nom ] {PRIMARY KEY | UNIQUE | FOREIGN KEY | CHECK (_condicio_)} (c11 [,c12][,...]) [ REFERENCES taula2 [ (c21 [,c22][,...]) ] ] [ ON DELETE {CASCADE | SET NULL}] [ON UPDATE {CASCADE | SET NULL}] ] Igual que abans, si no posem nom a la restricci\u00f3 (CONSTRAINT nom) PostgreSQL li n'assignar\u00e0 un autom\u00e0ticament, que ser\u00e0 constru\u00eft de manera molt l\u00f2gica. Observeu que ara sempre especifiquem el o els camps afectats. Els tipus de restriccions s\u00f3n els mateixos que en el cas anterior, per\u00f2 la sintaxi variar\u00e0 lleugerament: Restricci\u00f3 de clau principal PRIMARY KEY : posarem entre par\u00e8ntesis el camp o camps (en aquest cas separats per comes) que seran clau principal. Per exemple, definim una altra vegada el camp dni com a clau principal de la taula EMPLEAT3 CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT cp_emp3 PRIMARY KEY (dni) ) I ara un altre per a definir la clau principal de FAMILIAR. Com la clau est\u00e0 formada per 2 camps, estem obligats a utilitzar una restricci\u00f3 de camp m\u00faltiple. CREATE TABLE FAMILIAR ( dni VARCHAR(10), nom VARCHAR, data_n DATE, parentesc VARCHAR(50), CONSTRAINT cp_fam2 PRIMARY KEY (dni,nom) ) Com coment\u00e0vem, si la clau principal est\u00e0 formada per 2 camps estarem obligats a utilitzar una restricci\u00f3 de camp m\u00faltiple. Un error prou com\u00fa seria el seg\u00fcent: CREATE TABLE FAMILIAR2 ( dni VARCHAR(10) PRIMARY KEY, nom VARCHAR PRIMARY KEY, data_n DATE, parentesc VARCHAR(50) ) Podeu comprovar que donar\u00e0 error , perqu\u00e8 estem intentant definir 2 claus principals. La clau principal \u00e9s \u00fanica, aix\u00f2 s\u00ed formada per 2 camps en aquesta ocasi\u00f3. Restricci\u00f3 d'unicitat UNIQUE : ara posarem entre par\u00e8ntesis el o els camps que seran \u00fanics (en el seu conjunt). PostgreSQL generar\u00e0 autom\u00e0ticament un \u00edndex per a aquesta combinaci\u00f3 de camps. Veurem qu\u00e8 \u00e9s un \u00edndex en la pregunta 6. Per exemple, modifiquem la definici\u00f3 de EMPLEAT3 (anomenant-la EMPLEAT4) , amb un camp per als cognoms i un camp per al nom . Definirem la restricci\u00f3 que els camps cognoms i nom (en conjunt) no es poden repetir. CREATE TABLE EMPLEAT4 ( dni VARCHAR(10), cognoms VARCHAR, nom VARCHAR, data_naixement DATE, sou NUMERIC(6,2) , departament INT2 , CONSTRAINT u_nom4 UNIQUE (cognoms,nom) ) Restricci\u00f3 de valor no nul NOT NULL . No existeix aquesta opci\u00f3 com a restricci\u00f3 m\u00faltiple. Per tant s'ha de definir sempre com a restricci\u00f3 de camp \u00fanic. Restricci\u00f3 d'integritat referencial FOREIGN KEY : servir\u00e0 per a definir que aquest o aquestos camps s\u00f3n una clau externa. \u00c9s la que m\u00e9s varia en la seua sintaxi, ja que hem d'especificar tant el o els camps d'aquesta taula que s\u00f3n clau externa, com la taula a la qual apunta (i en tot cas el o els camps on s'apunta, encara que si no ho posem apuntar\u00e0 a la clau principal de l'altra taula, cosa que voldrem sempre): [CONSTRAINT nom] FOREIGN KEY (c11 [,c12][,...]) REFERENCES taula2 [(c21 [,c22][,...])] [ON DELETE {CASCADE | SET NULL}] [ON UPDATE {CASCADE | SET NULL}] En l'exemple de la clau externa que apunta a la taula DEPARTAMENT quedar\u00e0 aix\u00ed: CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT ce_emp3_dep FOREIGN KEY (departament) REFERENCES DEPARTAMENT ) Restricci\u00f3 externa CHECK : ara la condici\u00f3 de validaci\u00f3 podr\u00e0 afectar a m\u00e9s d'un camp Per exemple podr\u00edem exigir que la data d'incorporaci\u00f3 siga estrictament posterior a la data de naixement CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT check_dates CHECK (data_incorporacio > data_naixement) ) O una altra una miqueta m\u00e9s real, anem a agafar empleats de m\u00e9s de 18 anys, i per tant anem a exigir que la data d'incorporaci\u00f3 siga m\u00e9s de 18 anys posterior a la data de naixement. Per a aix\u00f2 utilitzem la funci\u00f3 AGE(f1,f2) que calcula el temps entre la data d2 i la data d1 (que ha de ser la posterior), i d'ah\u00ed extraurem els anys amb EXTRACT(year FROM ...) CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) , nom VARCHAR , data_naixement DATE , sou NUMERIC(6,2) , departament INT2 , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT check_dates CHECK (EXTRACT(year FROM AGE(data_incorporacio,data_naixement) ) >=18 ) ) Evidentment, es poden barrejar les restriccions de camp \u00fanic i les de camp m\u00faltiple. Ac\u00ed en tenim un exemple on s'arrepleguen moltes (no totes) les restriccions anteriors. Hem posat de camp m\u00faltiple la dels 18 anys dels empleats, perqu\u00e8 no hi ha un altre remei, i tamb\u00e9 la de no repetici\u00f3 del camp nom , encara que podia ser de camp \u00fanic: CREATE TABLE EMPLEAT3 ( dni VARCHAR(10) CONSTRAINT cp_emp3 PRIMARY KEY , nom VARCHAR CONSTRAINT nn_nom NOT NULL , data_naixement DATE , sou NUMERIC(6,2) CONSTRAINT sou_positiu CHECK (sou > 0) , departament INT2 CONSTRAINT ce_emp3_dep REFERENCES DEPARTAMENT , poblacio VARCHAR(50) DEFAULT 'Castell\u00f3' , data_incorporacio DATE DEFAULT CURRENT_DATE , CONSTRAINT u_nom3 UNIQUE (nom) , CONSTRAINT check_dates CHECK (EXTRACT(year FROM AGE(data_incorporacio,data_naixement) ) >=18 ) )","title":"2.2.1.2 Restriccions de camp m\u00faltiple"},{"location":"2_ddl/#exercicis_1","text":"En factura_local : Ex_3 - Crear la taula PROVINCIA , amb la clau principal. Ex_4 - Crear la taula POBLE , amb la clau principal i la restricci\u00f3 que el camp cod_pro \u00e9s clau externa que apunta a PROVINCIA. Ex_5 - Crear la taula VENEDOR , amb la clau principal i la clau externa a POBLE (de moment no definim la clau externa a VENEDOR, que \u00e9s reflexiva). Ex_6 - Crear la taula CLIENT , amb la clau principal i la clau externa a POBLE Ex_7 - Crear la taula FACTURA , amb la clau principal i les claus externes a CLIENT i VENEDOR. Tamb\u00e9 heu d'exigir que cod_cli siga no nul. Ex_8 - Crear la taula LINIA_FAC , amb la clau principal (observa que est\u00e0 formada per 2 camps) per\u00f2 de moment sense la clau externa que apunta a ARTICLE. A m\u00e9s cod_a ha de ser no nul.","title":"Exercicis"},{"location":"2_ddl/#23-alter-table","text":"Permet modificar l'estructura d'una taula ja existent, b\u00e9 afegint, llevant o modificant camps (columnes), b\u00e9 afegint o llevant restriccions. Tamb\u00e9 servir\u00e0 per a canviar el nom d'un camp i fins i tot canviar el nom de la taula Sintaxi Per a alterar l'estructura d'algun camp o restricci\u00f3 utilitzarem aquesta sintaxi: ALTER TABLE taula {ADD | DROP | ALTER} {COLUMN camp | CONSTRAINT restricci\u00f3 m\u00faltiple} Per a canviar el nom d'un camp: ALTER TABLE taula RENAME [COLUMN] camp TO nou_nom_camp Per a canviar el nom de la taula: ALTER TABLE taula RENAME TO nou_nom_taula Afegir camp o restricci\u00f3 Si volem afegir una columna o una restricci\u00f3, l'haurem de definir totalment. En el cas d'un camp, haurem d'especificar el nom, el tipus i opcionalment una restricci\u00f3 que afecte nom\u00e9s al camp. Per exemple, aquesta sent\u00e8ncia afegeix el camp supervisor (de tipus text de 10) a la taula EMPLEAT3. Observeu que en la definici\u00f3 del camp poden entrar restriccions de camp \u00fanic. ALTER TABLE EMPLEAT3 ADD COLUMN supervisor VARCHAR(10) En el cas d'una restricci\u00f3, aquesta ser\u00e0 del tipus de restricci\u00f3 m\u00faltiple, amb la sintaxi que vam veure en l'apartat de restriccions. Per exemple, aquesta sent\u00e8ncia afegeix la clau externa reflexiva (de EMPLEAT3 a EMPLEAT3) que indica els supervisors. El dni hauria de ser la clau principal de EMPLEAT3 ALTER TABLE EMPLEAT3 ADD CONSTRAINT ce_emp3_emp3 FOREIGN KEY (supervisor) REFERENCES EMPLEAT3 (dni) Modificar un camp Podem fer dues coses: modificar el tipus del camp o modificar el valor per defecte (posar valor per defecte o llevar-lo) Per a canviar el tipus haurem d'utilitzar la sintaxi ... ALTER COLUMN camp TYPE nou_tipus **. Per exemple anem a fer que el camp poblacio siga de 25 car\u00e0cters ALTER TABLE EMPLEAT3 ALTER COLUMN poblacio TYPE VARCHAR(25) Canviar el tipus de dades \u00e9s autom\u00e0tic quan els tipus s\u00f3n compatibles entre ells. Si no ho s\u00f3n ens donar\u00e0 error, per\u00f2 segurament ho podrem esquivar amb la cl\u00e0usula USING , que ens permet posar a continuaci\u00f3 el camp i aprofitem per a posar un operador de conversi\u00f3 de tipus ( :: ) amb aquesta sintaxi : ALTER TABLE _TAULA_ ALTER COLUMN _camp_ TYPE _tipus_nou_ USING _camp_ ::_tipus_nou_ Per a canviar el valor per defecte utilitzarem la sintaxi : **... ALTER COLUMN camp {SET | DROP} DEFAULT [ expressi\u00f3 ] ** ALTER TABLE EMPLEAT3 ALTER COLUMN poblacio DROP DEFAULT Esborrar camp o restricci\u00f3 Si volem llevar un camp o una restricci\u00f3 \u00e9s suficient amb especificar el nom del camp o de la restricci\u00f3 (per aix\u00f2 pot ser molt interessant donar nom a les restriccions). En el primer exemple llevem la clau externa del supervisor. En la segona llevem el camp supervisor. ALTER TABLE EMPLEAT3 DROP CONSTRAINT ce_emp3_emp3; ALTER TABLE EMPLEAT3 DROP COLUMN supervisor Renomenar un camp Per exemple renomenem el camp data_incorporacio a data_inc : ALTER TABLE EMPLEAT3 RENAME COLUMN data_incorporacio TO data_inc Renomenar la taula Ara li posarem el nom EMP3 a la taula EMPLEAT3 ALTER TABLE EMPLEAT3 RENAME TO EMP3 Exemples 1) Modificar la taula EMP3 per afegir el camp cp (codi postal) de tipus text de 5 car\u00e0cters. ALTER TABLE EMP3 ADD COLUMN cp VARCHAR(5); 2) Modificar la taula EMP3 per modificar el camp anterior i que siga de tipus num\u00e8ric. ALTER TABLE EMP3 ALTER COLUMN cp TYPE NUMERIC(5) USING CP::NUMERIC; 3) Modificar la taula EMP3 per afegir la restricci\u00f3 (encara que siga un poc estranya) que no es pot repetir la combinaci\u00f3 codi postal i poblaci\u00f3. ALTER TABLE EMP3 ADD CONSTRAINT u_cp_pobl UNIQUE (cp,poblacio); 4) Modificar la taula EMP3 per esborrar la restricci\u00f3 anterior ALTER TABLE EMP3 DROP CONSTRAINT u_cp_pobl; 5) Modificar la taula EMP3 per modificar el nom del camp cp a codi_postal ALTER TABLE EMP3 RENAME COLUMN cp TO codi_postal; 6) Renomenar la taula EMP3 a EMPLEAT3 ALTER TABLE EMP3 RENAME TO EMPLEAT3;","title":"2.3 ALTER TABLE"},{"location":"2_ddl/#exercicis_2","text":"En factura_local : Ex_9 - Afegir un camp a la taula VENEDOR anomenat alies de tipus text, que ha de ser no nul i \u00fanic. Ex_10 - Esborrar el camp anterior, alies , de la taula VENEDOR . Ex_11 - Afegir la clau principal de CATEGORIA . Ex_12 - En la taula ARTICLE afegir la clau principal i la clau externa a CATEGORIA. Ex_13 - En la taula LINIA_FAC afegir la clau externa que apunta a FACTURA, exigint que s'esborre en cascada (si s'esborra una factura, s'esborraran autom\u00e0ticament les seues l\u00ednies de factura). I tamb\u00e9 la clau externa que apunta a ARTICLE (aquesta normal, \u00e9s a dir NO ACTION) Nota Per a no fer-lo massa llarg s'han deixat de definir alguna restricci\u00f3, concretament la reflexiva de VENEDOR a VENEDOR (que marca el cap)","title":"Exercicis"},{"location":"2_ddl/#24-drop-table","text":"Ens servir\u00e0 per esborrar absolutament una taula, tant les dades com l'estructura. S'ha d'anar amb compte amb ella, perqu\u00e8 \u00e9s una operaci\u00f3 que no es pot desfer, i per tant potencialment molt perillosa. Sintaxi DROP TABLE taula Exemples DROP TABLE FAMILIAR","title":"2.4 DROP TABLE"},{"location":"2_ddl/#25-index","text":"Els \u00edndex s\u00f3n estructures de dades que permeten mantenir ordenada una taula respecte a un o m\u00e9s d'un camp, cadascun d'ells de forma ascendent o descendent. Tenir un \u00edndex per un determinat camp o camps permet reduir dr\u00e0sticament el temps utilitzat en ordenar per ells (perqu\u00e8 ja es mant\u00e9 aquest ordre) i tamb\u00e9 quan es busca un determinat valor d'aquest camp, ja que com est\u00e0 ordenat es poden fer recerques bin\u00e0ries o dicot\u00f2miques. Quan no est\u00e0 ordenat no hi ha m\u00e9s remei que fer una recerca seq\u00fcencial, que \u00e9s considerablement m\u00e9s lenta. De tota manera no s'ha d'abusar dels \u00edndex, ja que \u00e9s una estructura addicional de dades que ocupar\u00e0 espai, i que com s'han de mantenir els \u00edndex constantment actualitzats, cada vegada que es realitza una operaci\u00f3 d'actualitzaci\u00f3 (inserci\u00f3, modificaci\u00f3 o esborrat) s'ha de reestructurar l'\u00edndex, per a posar o llevar l'element al seu lloc. Creaci\u00f3 d'\u00edndex A banda de la creaci\u00f3 expl\u00edcita d'\u00edndex que farem en aquesta pregunta, PostgreSQL crea impl\u00edcitament un \u00edndex cada vegada que: Creem una clau princpal Creem una restricci\u00f3 d'unicitat (UNIQUE) En ambd\u00f3s casos ser\u00e0 un \u00edndex que no es podr\u00e0 repetir. Per tant, en els casos anteriors no cal crear un \u00edndex, perqu\u00e8 PostgreSQL ja ho ha fet autom\u00e0ticament. En PostgreSQL la creaci\u00f3 d'\u00edndex \u00e9s molt completa. Anem a veure una versi\u00f3 resumida: Sintaxi CREATE [UNIQUE] INDEX nom_\u00edndex ON taula (c1 [ASC|DESC][, c2 [ASC|DESC], ...] [NULLS { FIRST | LAST }] ) Si posem l'opci\u00f3 UNIQUE impedir\u00e0 que es repetisquen els valors del camp (o camps) que formen l'\u00edndex, de forma similar a la restricci\u00f3 UNIQUE del CONSTRAINT. L'opci\u00f3 d'ordenaci\u00f3 per defecte \u00e9s l'ascendent. Podem fer que els nuls estiguen al principi de tot o al final de tot, segons ens convinga: FIRST : far\u00e0 que en l'ordenaci\u00f3, els valors nuls vagen abans de qualsevol altre valor. Aquesta \u00e9s l'opci\u00f3 per defecte, si l'ordre \u00e9s descendent, a m\u00e9s de crear l'\u00edndex fa que siga clau principal. Evidentment no ha d'haver una clau principal creada amb anterioritat. LAST : els valors nuls estaran al final de tot, despr\u00e9s de qualsevol altre valor. \u00c9s l'opci\u00f3 per defecte quan l'ordre \u00e9s ascendent. Exemples 1) Crear un \u00edndex en la taula EMPLEAT4 per al camp departament en ordre ascendent . CREATE INDEX i_dep ON EMPLEAT4 (departament); 2) Crear un index per al camp data_naixement (descendent) i sou (ascendent) en la taula EMPLEAT4 . En els dos casos, data_naixement i sou , s'han d'ordenar els valors nuls al final CREATE INDEX i_dat_sou ON EMPLEAT4 (data_naixement DESC NULLS LAST, sou NULLS LAST); Esborrar un \u00edndex La sent\u00e8ncia d'esborrar un \u00edndex \u00e9s molt senzilla. Nom\u00e9s hem d'especificar el nom de l'\u00edndex i la taula on est\u00e0 definit. DROP INDEX nom_\u00edndex ON taula","title":"2.5 \u00cdndex"},{"location":"2_ddl/#exercicis_3","text":"En factura_local : Ex_14 - Afegir un \u00edndex anomenat i_nom_cli a la taula CLIENT pel camp nom . Ex_15 - Afegir un \u00edndex anomenat i_adr_ven a la taula VENEDOR per a que estiga ordenat per cp (ascendent) i adreca (descendent).","title":"Exercicis"},{"location":"2_ddl/#26-vistes","text":"Les vistes, tamb\u00e9 anomenades esquemes externs, consisteixen en visions particulars de la B.D. Es correspon al nivell extern de l'arquitectura a tres nivells. Les taules, que s\u00f3n les que realment contenen les dades i donen la visi\u00f3 global de la B.D., corresponen al nivell conceptual. Creaci\u00f3 d'una vista Sintaxi CREATE VIEW _nom_vista_ AS _subconsulta_ [WITH READ ONLY]; on se li d\u00f3na un nom, \u00e9s el resultat d'una subconsulta (un SELECT), i tenim la possibilitat d'impedir la modificaci\u00f3 de les dades. Per exemple, una vista amb les comarques, el n\u00famero de poblacions de cada comarca, el total d'habitats i l'altura mitjana: CREATE OR REPLACE VIEW ESTADISTICA AS SELECT nom_c, count(nom) AS num_p,sum(poblacio) AS pobl, avg(altura) AS alt_mitjana FROM POBLACIONS GROUP BY nom_c ORDER BY nom_c; Nota Si voleu provar aquesta vista, ho podeu fer en la Base de Dades geo , ja que en ella tenim dades per a la consulta que proporciona les dades a la vista. Recordeu que ens estem connectant tots com el mateix usuari, per tant si alg\u00fa ha creat un objecte (en aquest cas una vista) no es podr\u00e0 utilitzar aquest nom per a crear un altre objecte. Per aix\u00f2 \u00e9s convenient que si feu una prova de crear un objecte, despr\u00e9s esborreu aquest objecte. Observeu la sintaxi CREATE OR REPLACE, que va molt b\u00e9 per a crear, i si ja existeix per a substituir. Com que estem accedint tots com el mateix usuari, ser\u00e0 prou normal que l'objecte ja existesca per haver-lo creat un company. D'aquesta manera el substituirem. No passa res per esborrar un objecte ja existent, ja que tot a\u00e7\u00f2 s\u00f3n proves. La manera d'utilitzar-la \u00e9s com una taula normal, per\u00f2 ja sabem, que en realitat les dades estan en les taules. SELECT * FROM ESTADISTICA; I fins i tot es pot jugar amb taules i vistes. En aquesta sent\u00e8ncia traurem la prov\u00edncia, nom de la comarca, n\u00famero de pobles i altura mitjana de les comarques amb 5 o menys pobles: SELECT provincia,COMARQUES.nom_c,num_p,alt_mitjana FROM COMARQUES , ESTADISTICA WHERE COMARQUES.nom_c=ESTADISTICA.nom_c and num_p <= 5; Esborrar una vista Per a esborrar una vista DROP VIEW _nom_vista_ Per exemple, per a esborrar la vista anterior:a esborrar una vista DROP VIEW ESTADISTICA;","title":"2.6 Vistes"},{"location":"2_ddl/#exercicis_4","text":"En factura_local : Ex_16 - Crear la vista RESUM_FACTURA , que ens d\u00f3ne el total dels diners de la factura, el total despr\u00e9s del descompte d'articles, i el total despr\u00e9s del descompte de la factura, tal i com ten\u00edem en la consulta Ex_56 . A partir d'aquest moment podrem utilitzar la vista per a traure aquestos resultats Ex 17 - Crear la vista RESUM_VENEDOR , on aparega informaci\u00f3 del nom del venedor, del nombre total d'articles venuts i de l'import total facturat. Ex 18 - Crear la vista RESUM_CATEGORIAS , on aparega informaci\u00f3 del nom de la categoria, del nombre total d'articles venuts i de l'import total facturat.","title":"Exercicis"},{"location":"2_ddl/#27-creacio-daltres-objectes-sequencies-dominis-i-tipus","text":"Una de les caracter\u00edstiques de PostgreSQL \u00e9s la seua gran versatilitat. En concret es poden crear molts objectes. A banda dels habituals, vistes, seq\u00fc\u00e8ncies,... es poden xcrear m\u00e9s tipus d'objectes. En aquest curs donarem una ulladeta als dominis i la definici\u00f3 de nous tipus de dades. Hem de tenir en consideraci\u00f3 que tots ens connectarem com el mateix usuari per a fer proves. Per tant els objectes que creem poden fastidiar a altres companys si utilitzem tots els mateixos noms. En altres SGBD (com per exemple Oracle) existeix la possibilitat de crear els objectes posant CREATE OR REPLACE ... , que si no existeix el crea, i si existeix el substitueix. Lamentablement en PostgreSQL dep\u00e9n de la versi\u00f3: en les m\u00e9s modernes s\u00ed que es pot, per\u00f2 en versions anteriors no podrem, excepte en les vistes i les funcions.","title":"2.7. Creaci\u00f3 d'altres objectes: seq\u00fc\u00e8ncies, dominis i tipus."},{"location":"2_ddl/#271-sequencies","text":"Creaci\u00f3 d'una seq\u00fc\u00e8ncia Tamb\u00e9 es poden crear seq\u00fc\u00e8ncies ( SEQUENCE ), que s\u00f3n objectes que agafen valors num\u00e8rics que van incrementant-se (com l'autonum\u00e8ric). Sintaxi CREATE SEQUENCE _nom_seq\u00fc\u00e8ncia_ [START WITH _valor_inicial_] [INCREMENT BY _valor_increment_] ... ; La sent\u00e8ncia \u00e9s m\u00e9s llarga, per a considerar m\u00e9s casos. Per a nosaltres est\u00e0 b\u00e9 aix\u00ed. Per defecte, el valor inicial \u00e9s 1, i l'increment tamb\u00e9 1. \u00c9s un objecte independent de les taules. S'utilitza de la seg\u00fcent manera: CURRVAL(' nom_seq\u00fc\u00e8ncia ') torna el valor actual (ha d'estar inicialitzat) NEXTVAL(' nom_seq\u00fc\u00e8ncia ') incrementa la seq\u00fc\u00e8ncia i torna el nou valor (excepte la primera vegada que l'inicia amb el valor inicial) La manera habitual d'utilitzar-lo ser\u00e0 per obtenir un valor que s'afegir\u00e0 a un camp d'una taula (normalment la clau principal). Suposem que tenim una taula anomenada FACTURA amb l'estructura que ve a continuaci\u00f3, i volem que la clau principal siga un autonum\u00e8ric. Ho podem provar sobre la Base de Dades i usuari proves . CREATE TABLE FACTURA ( num_f NUMERIC(7) CONSTRAINT cp_fact PRIMARY KEY, data DATE, client VARCHAR(10)); Primer ens crearem la seq\u00fc\u00e8ncia: CREATE SEQUENCE s_num_fac START WITH 2016001; Despr\u00e9s l'utilitzem: INSERT INTO FACTURA VALUES (NEXTVAL('s_num_fac'), '15-01-2016','cli001'); Si ara mirem el contingut de la taula FACTURA obtindrem: O fins i tot en el moment de declarar la taula, li posem un valor per defecte al camp, que ser\u00e0 el seg\u00fcent de la seq\u00fc\u00e8ncia. No haurem d'introduir ara res en la columna num_f , que agafa el valor de la seq\u00fc\u00e8ncia CREATE TABLE FACTURA2 ( num_f NUMERIC(7) CONSTRAINT cp_fact2 PRIMARY KEY DEFAULT NEXTVAL('s_num_fac'), data DATE, client VARCHAR(10)); INSERT INTO FACTURA2(data,client) VALUES ('15-01-2016','cli001'); Observeu tamb\u00e9 que en la taula FACTURA2, el valor comen\u00e7a per 2016002 , ja que el primer valor l'hav\u00edem utilitzat en FACTURA. Per tant el contingut de la taula FACTURA2 ser\u00e0: Tamb\u00e9 ho podr\u00edem haver fet declarant la clau de tipus SERIAL , que el que fa \u00e9s implementar una seq\u00fc\u00e8ncia, i donar valors successius per al camp on est\u00e0 definida. Per\u00f2 d'aquesta manera la seq\u00fc\u00e8ncia comen\u00e7a sempre per 1 CREATE TABLE FACTURA3 ( num_f SERIAL CONSTRAINT cp_fact3 PRIMARY KEY, data DATE, client VARCHAR(10)); I despr\u00e9s fer la inserci\u00f3 d'aquesta manera: INSERT INTO FACTURA3(data,client) VALUES ('15-01-2016','cli001') Com coment\u00e0vem, el valor introdu\u00eft per la seq\u00fc\u00e8ncia ser\u00e0 1 : Tornarem a veure aquest exemple en les consultes d'actualitzaci\u00f3, concretament el INSERT . Esborrar una seq\u00fc\u00e8ncia Per a esborrar una seq\u00fc\u00e8ncia utilitzarem la sent\u00e8ncia DROP SEQUENCE : DROP SEQUENCE s_num_fac De moment aquesta sent\u00e8ncia ens donaria error, ja que la taula FACTURA2 utilitza aquesta seq\u00fc\u00e8ncia. Esborrarem primer les 3 taules, i despr\u00e9s la seq\u00fc\u00e8ncia per a no interferir amb els companys/es. DROP TABLE FACTURA, FACTURA2, FACTURA3; DROP SEQUENCE s_num_fac;","title":"2.7.1 Seq\u00fc\u00e8ncies"},{"location":"2_ddl/#272-dominis","text":"Els dominis s\u00f3n els conjunts de valors que pot agafar un determinat camp. Habitualment es posa senzillament un tipus de dades. Per\u00f2 el model relacional te\u00f2ric \u00e9s m\u00e9s restrictiu, i els dominis encara podrien ser subconjunts d'aquestos tipus de dades. Creaci\u00f3 d'un domini Normalment aquestos subconjunts es realitzen per mig dels check , que permeten una regla de validaci\u00f3 (una condici\u00f3) per a donar les dades com a bones (per exemple, un sou sempre \u00e9s positiu, per tant, a banda de fer que siga num\u00e8ric podr\u00edem obligar a que f\u00f3ra positiu). Sintaxi CREATE DOMAIN nom AS data_tipus [CHECK(expresi\u00f3)| NOT NULL | NULL ]; PostgreSQL permet definir dominis, que seran d'un determinat tipus base, d'una grand\u00e0ria determinada (opcional), amb un valor per defecte (opcional) i fins i tot amb una cl\u00e0usula check . A partir d'aquest moment, un o m\u00e9s d'un camp els podrem definir d'aquest domini (amb l'avantatge que canviant el domini canviem el tipus de tots els camps que el tenen). Anem a veure alguns exemples que es poden realitzar sobre l'usuari proves . CREATE DOMAIN sou AS numeric(7,2) CHECK (VALUE > 0); Si us d\u00f3na error perqu\u00e8 ja existia el domini, senzillament esborreu el domini anterior i ho torneu a provar Ara podr\u00edem definir la taula: CREATE TABLE EMPLEAT5 ( cod_e varchar(5) primary key, nom_e varchar(50), salari sou); Si intentem introduir la dada del sou malament (per exemple posant-lo negatiu) veurem que d\u00f3na error. Un altre exemple, que farem sobre la Base de Dades proves , encara que \u00e9s un exemple basat en les taules que ten\u00edem en geo . En la taula de POBLACIONS tenim les coordenades ( latitud i longitud ). Podr\u00edem intentar fer uns dominis per a marcar l' hemisferi (N S per a latitud, i E W per a longitud), els graus de latitud (-90\u00ba a 90\u00ba), graus de longitud (-180\u00ba a 180\u00ba) en longitud, per als minuts (0' a 59') , segons (0\u201d a 59\u201d). Centrem-nos en la latitud: CREATE DOMAIN hemi_lat AS char(1) CHECK (VALUE IN ('N','S')); CREATE DOMAIN graus_lat AS numeric(2) CHECK (VALUE BETWEEN 0 AND 90); CREATE DOMAIN min_seg AS numeric(2) CHECK (VALUE BETWEEN 0 AND 59); Ara podr\u00edem definir una alternativa a la taula de POBLACIONS: CREATE TABLE POBLACIONS2 ( nom VARCHAR(50) CONSTRAINT cp_pob2 PRIMARY KEY, lat_h hemi_lat, lat_g graus_lat, lat_m min_seg, lat_s min_seg); i comprovar\u00edem que les latituds s'han d'introduir correctament. Si posem per exemple els minuts malament, d\u00f3na error INSERT INTO POBLACIONS2 VALUES('Illes Columbretes','N',39,73,57); Per\u00f2 no hi ha problema si les dades s\u00f3n correctes. INSERT INTO POBLACIONS2 VALUES('Illes Columbretes','N',39,53,57); Esborrar un domini Per a esborrar un domini, utilitzarem DROP DOMAIN. Sintaxi DROP DOMAIN [IF EXISTS] nom [CASCADE | RESTRICT] RESTRICT rebutja eliminar el domini si hi ha objectes que depenen d'ell. Aquest \u00e9s el valor predeterminat. Exemple DROP DOMAIN sou; Si algun camp est\u00e0 definit amb el domini que esborrem, donar\u00e0 error. Si esborr\u00e0rem amb l'opci\u00f3 CASCADE, s'esborrarien els camps de les taules amb aquest domini. Per a deixar que els companys/es puguen treballar tamb\u00e9, esborrem tot el que hem creat: DROP TABLE EMPLEAT5; DROP DOMAIN sou; Encara no esborrem els dominis hemi_lat , graus_lat i min_seg , perqu\u00e8 els utilitzarem en la seg\u00fcent pregunta.","title":"2.7.2 Dominis"},{"location":"2_ddl/#273-tipus-de-dades","text":"Ja hav\u00edem comentat que PosgreSQL \u00e9s molt vers\u00e0til, i permet a l'usuari crear tipus de dades personals. Tres s\u00f3n les maneres de crear un tipus de dades: compost, enumerat i extern. Compost \u00e9s com un registre, on s'especifiquen els camps i els tipus. Enumenat : posarem els possibles valors entre par\u00e8ntesis. Extern \u00e9s molt m\u00e9s complet i complex que permet crear un nou tipus base, amb una estructura interna i amb funcions, normalment creades en C, d'entrada (per a introduir la dada) i eixida (per a representar-la), d'an\u00e0lisi, ... Aquest tipus s'escapa dels objectius d'aquest curs Creaci\u00f3 de tipus de data Compost Sintaxi Posarem entre par\u00e8ntesi el nom dels camps i el tipus que formaran part d'aquest tipus compost. CREATE TYPE nom AS ([nom_camp tipo_camp] [,..]) Exemple Per exemple, sobre la Base de Dades proves : CREATE TYPE num_complex AS (a float4, b float4); que ens serviria per a representar n\u00fameros complexes. Si us d\u00f3na error perqu\u00e8 ja existieix el tipus (perqu\u00e8 l'ha creat un company/a), senzillament esborreu- lo abans i ho torneu a provar Un altre exemple (no cal fer-lo, \u00e9s il\u00b7lustratiu nom\u00e9s): CREATE TYPE lat AS ( h char(1), g numeric(2,0), m numeric(2,0), s numeric(2,0)); per a representar la latitud, encara que podr\u00edem aprofitar els dominis creats en el punt anterior, i ens eixir\u00e0 millor (aquest s\u00ed que el podeu fer): CREATE TYPE lat AS ( h hemi_lat, g graus_lat, m min_seg, s min_seg); i el tipus lat haur\u00e0 de respectar les restriccions de cada domini dels quatre camps. Ara podr\u00edem definir una taula CREATE TABLE POBLACIONS3 ( nom VARCHAR(50) CONSTRAINT cp_pob3 PRIMARY KEY, latitud lat, comarca varchar(50)); D'aquesta manera queda molt compacte. Per exemple, aquesta introducci\u00f3 de dades donar\u00e0 un error, ja que l'hemisferi no \u00e9s correcte: INSERT INTO POBLACIONS3 VALUES ('Castell\u00f3','(K,39,59,10)','Plana Alta'); En canvi aquesta funcionar\u00e0 perfectament: INSERT INTO POBLACIONS3 VALUES ('Castell\u00f3','(N,39,59,10)','Plana Alta'); Per a accedir als camps dels tipus compostos, b\u00e9 ja definits, b\u00e9 definits per nosaltres, haurem de posar el nom de la columna seguida d'un punt i seguit del nom del camp. Per\u00f2 en les sent\u00e8ncies SQL se'ns presenta un problema: que aquesta sintaxi serveix per a posar tamb\u00e9 el nom de la taula seguit del nom de la columna. Aix\u00ed per exemple ens donar\u00e0 error la seg\u00fcent sent\u00e8ncia, en la que volem traure el nom de la poblaci\u00f3, la latitud i si est\u00e0 en l'hemisferi nord o sud: SELECT nom, latitud, latitud.h FROM POBLACIONS3; L'error el d\u00f3na perqu\u00e8 en latitud.h espera que latitud siga una taula i h una columna. La manera d'esquivar aquest error \u00e9s posar entre par\u00e8ntesis la columna: SELECT nom, latitud, (latitud).h FROM POBLACIONS3; En el tema seg\u00fcent, el de programaci\u00f3 en PL/pgSQL veurem que all\u00e0 no caldr\u00e0 posar els par\u00e8ntesis, perqu\u00e8 no hi haur\u00e0 la confusi\u00f3 de taula.columna Creaci\u00f3 de tipus de data Enumerat El tipus enumerat \u00e9s un conjunt de dades est\u00e0tiques definides en el moment de la creaci\u00f3 del tipus, amb un ordre tamb\u00e9 predefinit. Est\u00e0 disponible des de la versi\u00f3 8.3 de PostgreSQL. Sintaxi CREATE TYPE nom AS ENUM ('element' [,...]) Exemple CREATE TYPE d_set AS ENUM ('dilluns','dimarts','dimecres','dijous','divendres','dissabte','diumenge'); Posteriorment el podrem utilitzar, per exemple, en la definici\u00f3 d'una taula: CREATE TABLE HORARI ( cod_pr NUMERIC(5) PRIMARY KEY, d_tut d_set, h_tut NUMERIC(4,2)); Ara el podem utilitzar. Haurem de tenir en compte que els valors s\u00f3n \u00fanicament els definits. I s'ha de respectar maj\u00fascules i minuscules. INSERT INTO HORARI VALUES (1,'dimarts',10); En canvi, aquesta donaria error : INSERT INTO HORARI VALUES (2,'Dimecres',12); ja que el nom de la setmana comen\u00e7a en maj\u00fascula. Introdu\u00efm algunes dades m\u00e9s INSERT INTO HORARI VALUES (2, 'dimecres',12) , (3,'dilluns',9) , (4,'divendres',11); Podem comprovar com l'ordre predefint \u00e9s el del moment de la creaci\u00f3 del tipus: SELECT * FROM HORARI ORDER BY d_tut; I com tamb\u00e9 es pot comprovar en aquesta sent\u00e8ncia: SELECT * FROM HORARI WHERE d_tut > 'dimarts'; on nom\u00e9s eixiran les files corresponents al dimecres i al divendres (files 2 i 4). Esborrar tipus de dades Per \u00faltim, anem a esborrar els objectes que hem creat, per a no interferir amb els companys: DROP TABLE POBLACIONS2 , POBLACIONS3 , HORARI ; DROP TYPE num_complex , lat , d_set ; DROP DOMAIN hemi_lat , graus_lat , min_seg ;","title":"2.7.3 Tipus de dades"},{"location":"2_ddl/#exercicis_5","text":"En factura_local : Ex 19 - Tenim creada la taula VENEDOR i es desitja que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica personalitzada. Observa la informaci\u00f3 actual en la taula VENEDOR de la BD factura i analitza quina seq\u00fc\u00e8ncia s'ha utilitzat. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte la seq\u00fc\u00e8ncia creada, per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat Ex 20 - Volem crear una nova taula CLIENT2 i es vol que la clau principal siga una seq\u00fc\u00e8ncia personalitzada autonumerica. Observa la informaci\u00f3 actual en la taula CLIENT de la BD factura i analitza quina seq\u00fc\u00e8ncia s'hauria de utilitzat. Has de tindre en compte que al crear la taula CLIENT2 perqu\u00e8 el camp cod_cli, per defecte sempre agafe el valor seg\u00fcent de la seq\u00fc\u00e8ncia definida anteriorment. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte els canvis realitzats en la base de dades. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 21 - En la taula FACTURA2 es vol que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica en s\u00e8rie. Crea la taula FACTURA2 perqu\u00e8 el camp num_f utilitze una seq\u00fc\u00e8ncia en s\u00e8rie. A m\u00e9s has de tindre en compte que el iva de la factura solament pot ser el 10 o el 21 i que el descompte la factura ha de ser inferior a 50. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 22 - Crea la taula ARTICLE2 tenint en compte el seg\u00fcent; Comprovar que el preu, stock i stock_min no \u00e9s negatiu Crear un tipus de dades per a l'estat d'un article, que pot prendre els valors \"Disponible\", \"Esgotat\" o \"En espera\". Crea un tipus de dada per a registrar el codi de barres EAN-13 d'un article. Tenint en compte que el codi de barres EAN-13 s'observen 3 parts: Pa\u00eds de proced\u00e8ncia: s\u00f3n els dos o tres primers d\u00edgits i, en el cas d'Espanya, aquest prefix \u00e9s el 84. Codi del producte: seg\u00fcents 9 o 10 d\u00edgits. D\u00edgit de control: \u00e9s un sol n\u00famero, l'\u00faltim, i serveix per a corroborar que el codi \u00e9s correcte. Comprovar que stock no pot ser inferior a stock _min (HAS DE DEFINIR UNA CONSTRAINT) A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona.. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"exercicis_de_tot_el_tema/","text":"Exercicis de tot el tema Al llarg d'aquesta tercera part, en el conjunt d'exercicis de DDL, crearem tota l'estructura de la Base de Dades FACTURA , per\u00f2 per a no interferir cadasc\u00fa amb els altres companys, cadasc\u00fa es connectar\u00e0 a la seua Base de Dades factura_local . L'esquema Entitat-Relaci\u00f3 i l'esquema relacional que implementarem ser\u00e0 el seg\u00fcent: Nota Durant tots aquestos exercicis de DDL pot ser molt convenient tenir obertes les dues connexions: la de FACTURA (per anar consultant) i la de factura_local (per anar creant i modificant). Ex_1 - Creeu la taula CATEGORIA , amb els mateixos camps i del mateix tipus que en la taula CATEGORIA de FACTURA , per\u00f2 de moment sense clau principal ni cap altra restricci\u00f3. Ex_2 - Creeu la taula ARTICLE , tamb\u00e9 sense restriccions. Ex_3 - Crear la taula PROVINCIA , amb la clau principal. Ex_4 - Crear la taula POBLE , amb la clau principal i la restricci\u00f3 que el camp cod_pro \u00e9s clau externa que apunta a PROVINCIA. Ex_5 - Crear la taula VENEDOR , amb la clau principal i la clau externa a POBLE (de moment no definim la clau externa a VENEDOR, que \u00e9s reflexiva). Ex_6 - Crear la taula CLIENT , amb la clau principal i la clau externa a POBLE Ex_7 - Crear la taula FACTURA , amb la clau principal i les claus externes a CLIENT i VENEDOR. Tamb\u00e9 heu d'exigir que cod_cli siga no nul. Ex_8 - Crear la taula LINIA_FAC , amb la clau principal (observa que est\u00e0 formada per 2 camps) per\u00f2 de moment sense la clau externa que apunta a ARTICLE. A m\u00e9s cod_a ha de ser no nul. Ex_9 - Afegir un camp a la taula VENEDOR anomenat alies de tipus text, que ha de ser no nul i \u00fanic. Ex_10 - Esborrar el camp anterior, alies , de la taula VENEDOR . Ex_11 - Afegir la clau principal de CATEGORIA . Ex_12 - En la taula ARTICLE afegir la clau principal i la clau externa a CATEGORIA. Ex_13 - En la taula LINIA_FAC afegir la clau externa que apunta a FACTURA, exigint que s'esborre en cascada (si s'esborra una factura, s'esborraran autom\u00e0ticament les seues l\u00ednies de factura). I tamb\u00e9 la clau externa que apunta a ARTICLE (aquesta normal, \u00e9s a dir NO ACTION) Ex_14 - Afegir un \u00edndex anomenat i_nom_cli a la taula CLIENT pel camp nom . Ex_15 - Afegir un \u00edndex anomenat i_adr_ven a la taula VENEDOR per a que estiga ordenat per cp (ascendent) i adreca (descendent). Ex_16 - Crear la vista RESUM_FACTURA , que ens d\u00f3ne el total dels diners de la factura, el total despr\u00e9s del descompte d'articles, i el total despr\u00e9s del descompte de la factura, tal i com ten\u00edem en la consulta 6.56 . A partir d'aquest moment podrem utilitzar la vista per a traure aquestos resultats Ex 17 - Crear la vista RESUM_VENEDOR, on aparega informaci\u00f3 del nom del venedor, del nombre total d'articles venuts i de l'import total facturat. Ex 18 - Crear la vista RESUM_CATEGORIAS, on aparega informaci\u00f3 del nom de la categoria, del nombre total d'articles venuts i de l'import total facturat. Ex 19 - Tenim creada la taula VENEDOR i es desitja que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica personalitzada. Observa la informaci\u00f3 actual en la taula VENEDOR de la BD factura i analitza quina seq\u00fc\u00e8ncia s'ha utilitzat. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte la seq\u00fc\u00e8ncia creada, per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat Ex 20 - Volem crear una nova taula CLIENT2 i es vol que la clau principal siga una seq\u00fc\u00e8ncia personalitzada autonumerica. Observa la informaci\u00f3 actual en la taula CLIENT de la BD factura i analitza quina seq\u00fc\u00e8ncia s'hauria de utilitzat. Has de tindre en compte que al crear la taula CLIENT2 perqu\u00e8 el camp cod_cli, per defecte sempre agafe el valor seg\u00fcent de la seq\u00fc\u00e8ncia definida anteriorment. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte els canvis realitzats en la base de dades. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 21 - En la taula FACTURA2 es vol que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica en s\u00e8rie. Crea la taula FACTURA2 perqu\u00e8 el camp num_f utilitze una seq\u00fc\u00e8ncia en s\u00e8rie. A m\u00e9s has de tindre en compte que el iva de la factura solament pot ser el 10 o el 21 i que el descompte la factura ha de ser inferior a 50. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 22 - Crea la taula ARTICLE2 tenint en compte el seg\u00fcent; Comprovar que el preu, stock i stock_min no \u00e9s negatiu Crear un tipus de dades per a l'estat d'un article, que pot prendre els valors \"Disponible\", \"Esgotat\" o \"En espera\". Crea un tipus de dada per a registrar el codi de barres EAN-13 d'un article. Tenint en compte que el codi de barres EAN-13 s'observen 3 parts: Pa\u00eds de proced\u00e8ncia: s\u00f3n els dos o tres primers d\u00edgits i, en el cas d'Espanya, aquest prefix \u00e9s el 84. Codi del producte: seg\u00fcents 9 o 10 d\u00edgits. D\u00edgit de control: \u00e9s un sol n\u00famero, l'\u00faltim, i serveix per a corroborar que el codi \u00e9s correcte. Comprovar que stock no pot ser inferior a stock _min (HAS DE DEFINIR UNA CONSTRAINT) A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona.. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis del tot el tema"},{"location":"exercicis_de_tot_el_tema/#exercicis-de-tot-el-tema","text":"Al llarg d'aquesta tercera part, en el conjunt d'exercicis de DDL, crearem tota l'estructura de la Base de Dades FACTURA , per\u00f2 per a no interferir cadasc\u00fa amb els altres companys, cadasc\u00fa es connectar\u00e0 a la seua Base de Dades factura_local . L'esquema Entitat-Relaci\u00f3 i l'esquema relacional que implementarem ser\u00e0 el seg\u00fcent: Nota Durant tots aquestos exercicis de DDL pot ser molt convenient tenir obertes les dues connexions: la de FACTURA (per anar consultant) i la de factura_local (per anar creant i modificant). Ex_1 - Creeu la taula CATEGORIA , amb els mateixos camps i del mateix tipus que en la taula CATEGORIA de FACTURA , per\u00f2 de moment sense clau principal ni cap altra restricci\u00f3. Ex_2 - Creeu la taula ARTICLE , tamb\u00e9 sense restriccions. Ex_3 - Crear la taula PROVINCIA , amb la clau principal. Ex_4 - Crear la taula POBLE , amb la clau principal i la restricci\u00f3 que el camp cod_pro \u00e9s clau externa que apunta a PROVINCIA. Ex_5 - Crear la taula VENEDOR , amb la clau principal i la clau externa a POBLE (de moment no definim la clau externa a VENEDOR, que \u00e9s reflexiva). Ex_6 - Crear la taula CLIENT , amb la clau principal i la clau externa a POBLE Ex_7 - Crear la taula FACTURA , amb la clau principal i les claus externes a CLIENT i VENEDOR. Tamb\u00e9 heu d'exigir que cod_cli siga no nul. Ex_8 - Crear la taula LINIA_FAC , amb la clau principal (observa que est\u00e0 formada per 2 camps) per\u00f2 de moment sense la clau externa que apunta a ARTICLE. A m\u00e9s cod_a ha de ser no nul. Ex_9 - Afegir un camp a la taula VENEDOR anomenat alies de tipus text, que ha de ser no nul i \u00fanic. Ex_10 - Esborrar el camp anterior, alies , de la taula VENEDOR . Ex_11 - Afegir la clau principal de CATEGORIA . Ex_12 - En la taula ARTICLE afegir la clau principal i la clau externa a CATEGORIA. Ex_13 - En la taula LINIA_FAC afegir la clau externa que apunta a FACTURA, exigint que s'esborre en cascada (si s'esborra una factura, s'esborraran autom\u00e0ticament les seues l\u00ednies de factura). I tamb\u00e9 la clau externa que apunta a ARTICLE (aquesta normal, \u00e9s a dir NO ACTION) Ex_14 - Afegir un \u00edndex anomenat i_nom_cli a la taula CLIENT pel camp nom . Ex_15 - Afegir un \u00edndex anomenat i_adr_ven a la taula VENEDOR per a que estiga ordenat per cp (ascendent) i adreca (descendent). Ex_16 - Crear la vista RESUM_FACTURA , que ens d\u00f3ne el total dels diners de la factura, el total despr\u00e9s del descompte d'articles, i el total despr\u00e9s del descompte de la factura, tal i com ten\u00edem en la consulta 6.56 . A partir d'aquest moment podrem utilitzar la vista per a traure aquestos resultats Ex 17 - Crear la vista RESUM_VENEDOR, on aparega informaci\u00f3 del nom del venedor, del nombre total d'articles venuts i de l'import total facturat. Ex 18 - Crear la vista RESUM_CATEGORIAS, on aparega informaci\u00f3 del nom de la categoria, del nombre total d'articles venuts i de l'import total facturat. Ex 19 - Tenim creada la taula VENEDOR i es desitja que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica personalitzada. Observa la informaci\u00f3 actual en la taula VENEDOR de la BD factura i analitza quina seq\u00fc\u00e8ncia s'ha utilitzat. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte la seq\u00fc\u00e8ncia creada, per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat Ex 20 - Volem crear una nova taula CLIENT2 i es vol que la clau principal siga una seq\u00fc\u00e8ncia personalitzada autonumerica. Observa la informaci\u00f3 actual en la taula CLIENT de la BD factura i analitza quina seq\u00fc\u00e8ncia s'hauria de utilitzat. Has de tindre en compte que al crear la taula CLIENT2 perqu\u00e8 el camp cod_cli, per defecte sempre agafe el valor seg\u00fcent de la seq\u00fc\u00e8ncia definida anteriorment. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula tenint en compte els canvis realitzats en la base de dades. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 21 - En la taula FACTURA2 es vol que la clau principal siga una seq\u00fc\u00e8ncia autonum\u00e9rica en s\u00e8rie. Crea la taula FACTURA2 perqu\u00e8 el camp num_f utilitze una seq\u00fc\u00e8ncia en s\u00e8rie. A m\u00e9s has de tindre en compte que el iva de la factura solament pot ser el 10 o el 21 i que el descompte la factura ha de ser inferior a 50. A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Ex 22 - Crea la taula ARTICLE2 tenint en compte el seg\u00fcent; Comprovar que el preu, stock i stock_min no \u00e9s negatiu Crear un tipus de dades per a l'estat d'un article, que pot prendre els valors \"Disponible\", \"Esgotat\" o \"En espera\". Crea un tipus de dada per a registrar el codi de barres EAN-13 d'un article. Tenint en compte que el codi de barres EAN-13 s'observen 3 parts: Pa\u00eds de proced\u00e8ncia: s\u00f3n els dos o tres primers d\u00edgits i, en el cas d'Espanya, aquest prefix \u00e9s el 84. Codi del producte: seg\u00fcents 9 o 10 d\u00edgits. D\u00edgit de control: \u00e9s un sol n\u00famero, l'\u00faltim, i serveix per a corroborar que el codi \u00e9s correcte. Comprovar que stock no pot ser inferior a stock _min (HAS DE DEFINIR UNA CONSTRAINT) A continuaci\u00f3 realitza la inserci\u00f3 d'un registre en aquesta taula per a comprovar que funciona.. Finalment elimina els objectes creats. Escriu les sent\u00e8ncies en l'ordre adequat. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis de tot el tema"}]}